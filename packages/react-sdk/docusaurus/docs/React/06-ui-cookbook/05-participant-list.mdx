---
id: participant-list
title: Custom Participants List layout
---

## Introduction

The purpose of this guide is to help developers understand how to build a custom call participant list layout
using Stream React Video SDK. The guide will cover the necessary steps to connect to Stream's edge infrastructure,
join a call, and build the layout.

## About the Sample Application

To demonstrate the flexibility of our React Video SDK, we are going to build a custom layout that looks similar to
Zoom's Speaker View layout. We would be using Vite + TS SPA template.
The app boilerplate can be found [here](https://github.com/GetStream/stream-video-js/sample-apps/react/cookbook-participant-list).

This application allows a user to join a call by providing the call ID and type.
Once joined in a call, the user would be able to mute/unmute their audio and video and
display the video streams of all participants in a "Zoom Speaker View"-like layout.

The final layout looks like this:

![Final Layout](../assets/ui-cookbook/participant-list/final-layout.png)

## Prerequisites

Before we can join a call, we need to connect to Stream's edge infrastructure.
In order to do that, please follow these steps:

- Register for a Stream account and obtain your API key and secret.
- Install the Stream React Video SDK:
  - `npm install @stream-io/video-react-sdk`
  - `yarn add @stream-io/video-react-sdk`
- Initialize the SDK by passing in your API key, token and user information:
  - Note: for token generation, you can use our [Token Generator](https://getstream.io/chat/docs/token_generator/)

```tsx
import {
  StreamVideo,
  useCreateStreamVideoClient,
} from '@stream-io/video-react-sdk';

// This is the component that will render the custom layout.
// we can assume that the implementation of this component is empty for now.
import { SpeakerView } from './SpeakerView';

// We are going to use Vite's environment variables to store our API key and token.
// https://vitejs.dev/guide/env-and-mode.html#env-files
//
// You can use any other method to store your API key and token.
const apiKey = import.meta.env.VITE_STREAM_API_KEY as string;
const token = import.meta.env.VITE_STREAM_TOKEN as string;
const userId = import.meta.env.VITE_USER_ID as string;

export const App = () => {
  const client = useCreateStreamVideoClient({
    apiKey,
    tokenOrProvider: token,
    user: {
      id: userId,
    },
  });

  return (
    <StreamVideo client={client}>
      <SpeakerView />
    </StreamVideo>
  );
};
```

## Joining a Call

To join a call, we need to know its ID and type. The call ID and type can come from any source you like.
In our example, we are going to get the call ID and type from the URL query params.

Once we have that information, we can join the call by choosing one of the two options:

1. Declarative, using the [`<StreamMeeting />`](../03-ui/components.md#streammeeting) component.
2. Imperative, using the [`StreamVideoClient`](../04-call-engine/StreamVideoClient.md) API methods (advanced usage).

In our example, we are going to use the declarative approach because it is easier to understand and
has less code:

```tsx
import { useState } from 'react';
import {
  StreamMeeting,
  StreamVideo,
  useCreateStreamVideoClient,
} from '@stream-io/video-react-sdk';

// This is the component that will render the custom layout.
// we can assume that the implementation of this component is empty for now.
import { SpeakerView } from './SpeakerView';

const apiKey = import.meta.env.VITE_STREAM_API_KEY as string;
const token = import.meta.env.VITE_STREAM_TOKEN as string;
const userId = import.meta.env.VITE_USER_ID as string;

const randomId = () => Math.random().toString(36).substring(2, 12);

export const App = () => {
  const client = useCreateStreamVideoClient({
    apiKey,
    tokenOrProvider: token,
    user: {
      id: userId,
    },
  });

  // will load the call ID from the URL query params,
  // or generate a random one in case it is not present.
  const [callId, setCallId] = useState(() => {
    const params = new URLSearchParams(
      window.location.search || window.location.hash,
    );

    return params.get('call_id') || randomId();
  });

  return (
    <StreamVideo client={client}>
      <StreamMeeting callId={callId} callType="default">
        <SpeakerView />
      </StreamMeeting>
    </StreamVideo>
  );
};
```

Behind the scenes, the `<StreamMeeting />` component will set up and join a new [Call](../04-call-engine/Call.md) instance,
and it will expose down in the component tree through a React Context the [CallState](../04-call-engine/contexts.md/#streamcallprovider) object.

You can read more about this mechanism as part of our [React Bindings and Hooks documentation](../04-call-engine/01-overview.gen.mdx).

# Building the Layout

Now that we have successfully set up the React Video SDK and joined the call, we can start building our custom layout.
For that purpose, we are going to utilize some fundamental React Video SDK components and hooks.

- [`<ParticipantBox />`](../03-ui/components.md#participantbox) - A component that renders a video stream of a participant.
- [`useCall()`](../04-call-engine/contexts.md#usecall) - A hook that returns the current call instance. You can use this hook to access the call state and call methods.
- [`useParticipants()`](../04-call-engine/hooks.md#useparticipants) - A hook that returns the list of all participants in the call.
- [`useDominantSpeaker()`](../04-call-engine/hooks.md#usedominantspeaker) - A hook that returns the current dominant speaker in the call.

On top of these hooks, we are going to apply some custom participant sorting logic:

- Dominant Speaker will take the largest space in the layout.
- The rest of the participants will be sorted at the top of the screen according to the following criteria:
  - Participants with screen-share will be displayed first
  - Participants with audio and video will be displayed next
  - Followed by video-only participants
  - Followed by audio-only participants
  - Muted participants will be displayed last

Having the rules set, let's go and implement the sorting:

### Determine the Dominant Speaker

In some circumstances, the dominant speaker might not be present in the list of participants.
In that case, we heuristically determine the dominant speaker by looking at the participants and we try to
pick one who is either sharing their screen or has both audio and video enabled.

For that purpose, let's introduce our first custom hook:

```tsx
import { useMemo } from 'react';
import {
  SfuModels,
  StreamVideoParticipant,
  useDominantSpeaker,
  useParticipants,
} from '@stream-io/video-react-sdk';

/**
 * Returns the participant to be shown in the spotlight.
 * Usually this is the dominant speaker, but if there is no dominant speaker,
 * then it's the first participant with screen share or video and audio.
 */
export const useSpotlightParticipant = () => {
  const participants = useParticipants();
  const dominantSpeaker = useDominantSpeaker();
  return useMemo(() => {
    return (
      dominantSpeaker ||
      participants.find(
        (p) => hasScreenShare(p) || (hasVideo(p) && hasAudio(p)),
      ) ||
      participants[0]
    );
  }, [participants, dominantSpeaker]);
};

const hasScreenShare = (p: StreamVideoParticipant) =>
  p.publishedTracks.includes(SfuModels.TrackType.SCREEN_SHARE);

const hasVideo = (p: StreamVideoParticipant) =>
  p.publishedTracks.includes(SfuModels.TrackType.VIDEO);

const hasAudio = (p: StreamVideoParticipant) =>
  p.publishedTracks.includes(SfuModels.TrackType.AUDIO);
```

### Sort the other participants

Now that we have the dominant speaker, we can sort the rest of the participants.
Similar like for the spotlight participant, we are going to use a custom hook to encapsulate the sorting logic:

```tsx
import { useMemo } from 'react';
import { useParticipants } from '@stream-io/video-react-sdk';
import { useSpotlightParticipant } from './SpeakerView';

/**
 * Sorts participants so that:
 *  - the presenter is first,
 * - the dominant speaker is next,
 * - then video, then audio, then the rest.
 */
export const useSortedParticipants = () => {
  const participantInSpotlight = useSpotlightParticipant();
  const participants = useParticipants();
  const otherParticipants = useMemo(() => {
    return participants
      .filter(
        (p) =>
          hasScreenShare(participantInSpotlight) ||
          p !== participantInSpotlight,
      )
      .sort((a, b) => {
        if (hasScreenShare(a) && !hasScreenShare(b)) return -1;
        if (!hasScreenShare(a) && hasScreenShare(b)) return 1;

        if (
          (hasVideo(a) && hasAudio(a) && !hasVideo(b) && !hasAudio(b)) ||
          (hasVideo(a) && !hasAudio(a) && !hasVideo(b) && hasAudio(b))
        )
          return -1;

        if (!hasVideo(a) && !hasAudio(a) && hasVideo(b) && hasAudio(b))
          return 1;

        return 0;
      });
  }, [participants, participantInSpotlight]);

  return [participantInSpotlight, ...otherParticipants];
};
```

### Render the layout

Now that we have all the data we need, organized in the way we want, we can render the layout:

```tsx
import { PropsWithChildren } from 'react';
import {
  CancelCallButton,
  ParticipantBox,
  ScreenShareButton,
  SpeakingWhileMutedNotification,
  ToggleAudioPublishingButton,
  ToggleCameraPublishingButton,
  useCall,
} from '@stream-io/video-react-sdk';
import { useSortedParticipants } from './SpeakerView';

// will load the default styling for the React Video SDK
import '@stream-io/video-styling/dist/css/styles.css';
import './SpeakerView.scss';

export const SpeakerView = () => {
  const call = useCall()!;
  const [participantInSpotlight, ...otherParticipants] =
    useSortedParticipants();
  return (
    // "str-video" enables the default styling for the video SDK
    <div className="str-video speaker-view">
      {otherParticipants.length > 0 && (
        <div className="participants-bar">
          {otherParticipants.map((participant) => (
            <div className="participant-tile" key={participant.sessionId}>
              <ParticipantBox participant={participant} call={call} />
            </div>
          ))}
        </div>
      )}

      <div className="spotlight">
        {participantInSpotlight && (
          <ParticipantBox participant={participantInSpotlight} call={call} />
        )}
      </div>

      <CustomCallControls>
        <ScreenShareButton call={call} />
        <SpeakingWhileMutedNotification>
          <ToggleAudioPublishingButton />
        </SpeakingWhileMutedNotification>
        <ToggleCameraPublishingButton />
        <CancelCallButton
          call={call}
          onLeave={() => {
            console.log('onLeave callback called');
          }}
        />
      </CustomCallControls>
    </div>
  );
};

const CustomCallControls = ({ children }: PropsWithChildren<{}>) => {
  return <div className="str-video__call-controls">{children}</div>;
};
```

We won't be covering the styling in this tutorial, but you can find the full code in the [SpeakerView.scss](./SpeakerView.scss) file.

And that's it! We have successfully built our custom layout.

At last, you can find the running example of this guide [here](https://github.com/GetStream/stream-video-js/sample-apps/react/cookbook-participant-list).

## Further customization

The React Video SDK is built on top of the data model that our [call engine](../04-call-engine/01-overview.gen.mdx) exposes.
As such, you can use the same data model to build your own custom layouts.
You can go further and build your own custom components, but we advise to at least use some our base components and hooks
to make sure that you wouldn't have to re-implement some baked-in functionality like:
Simulcast, DynaScale, Track Subscription handling, muting/unmuting, etc.
