---
title: Call & Participant State
description: How the state is exposed
---

You can access call, participant and client state using hooks. These hooks are reactive (their value is updated on WebSocket events and API calls).

## Call state

To observe call state you need to provide a `Call` instance to the [`StreamCall` component](../../ui-components/core/stream-call).

Let's see an example where we use the `useCall` and `useCallCallingState` hooks to display some basic information about the call:

```tsx
export default function App() {
  let call: Call;

  return (
    <StreamCall call={call}>
      <CallUI />
    </StreamCall>
  );
}

const CallUI = () => {
  const call = useCall();
  const callingState = useCallCallingState();

  return (
    <div>
      <div>Call: {call?.data?.cid}</div>
      <div>State: {callingState}</div>
    </div>
  );
};
```

This approach makes it possible to access the call state and be notified about changes anywhere in your application without having to manually subscribe to WebSocket events.

The `StreamCall` component uses the `StreamCallProvider` under the hood.

## Participant state

If you want to display information about the joined participants of the call you can use these hooks:

- `useLocalParticipant`: the local participant is the logged-in user
- `useRemoteParticipants`: all participants except the local participant
- `useParticipants`: all participants, including local and remote participants
- `useParticipantCount`: the approximate participant count of the active call. This includes the [anonymous users](../client-auth/#anonymous-users) as well, it is computed on the server-side.

```tsx
export default function App() {
  let call: call;

  return (
    <StreamCall call={call}>
      <CallUI />
    </StreamCall>
  );
}

const CallUI = () => {
  const participantCount = useParticipantCount();
  const localParticipant = useLocalParticipant();

  return (
    <div>
      <div>Number of participants: {participantCount}</div>
      <div>Session ID: {localParticipant.sessionId}</div>
    </div>
  );
};
```

## Client state

To observe client state you need to provide a `StreamVideoClient` instance to the `StreamVideo` context provider:

Let's see an example:

If you want to observe the connected user you can use the `useConnectedUser` hook.

```tsx
export default function App() {
  let client: StreamVideoClient;

  return (
    <StreamVideo client={client}>
      <Header></Header>
    </StreamVideo>
  );
}

const Header = () => {
  const user = useConnectedUser();
  return <div>{user ? `Logged in: ${user.name}` : 'Logged out'}</div>;
};
```

This approach makes it possible to access the client state and be notified about changes anywhere in your application without having to manually subscribe to WebSocket events.
