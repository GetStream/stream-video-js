---
title: Audio Room Tutorial
description: How to build an audio room using Stream's video SDKs
---

In this guide, you'll build an audio room experience similar to Twitter Spaces / Clubhouse.

The final result will look like this:

// TODO add sample video

The code for the final result can also be found on GitHub, so if you're only interested in seeing the resulting code, go [here](https://github.com/GetStream/stream-video-ios-examples/tree/main/AudioRooms).

:::note
For the sake of simplicity, the code provided in this guide may be simplified in certain situations. However, there will always be a link to the repository with the full code, so that you'll be able to have a look at that.
:::

Alright, let's get started. Creating this app will require the following steps:

1. Setup the project
2. Describe the login flow
3. Creating rooms via the API
4. Querying calls (with watch)
5. Joining and leaving a room

### Setup the project

The first step is to set up a new project. We'll use `vite` to do this, but feel free to use any other tool that you like.

To keep things simple, we'll just work with plain React and Typescript:

```bash
yarn create vite audio-rooms-sample --template react-ts
```

:::note
The entire Stream team loves Typescript. If you're wondering why, consider checking [this post](https://getstream.io/blog/typescript-basics/) about the topic on our Blog.
:::

Next, we install the dependencies for the Stream package:

```bash
yarn add @stream-io/video-react-sdk
```

After that, we can create a new project in the [Stream Dashboard](https://getstream.io/dashboard/). Once logged in, you will be introduced to our dashboard. There you can manage your applications. The app represents Stream's dedicated infrastructure that will handle your app's video calls.
Make sure to [create a video application](TODO: image/gif showing the UI creating the app) in your Stream dashboard. The API key and secret will be generated automatically upon the app's creation. Those are the credentials we will need for authentication.

:::tip
If you don't have a Stream account yet, you can register and try it for free [here](https://getstream.io/try-for-free/).
:::

The last setup step is to create a `.env` file. This is where we will put our API key to keep it safe.
Create a `.env` file in the root of your project and paste this code in (and replace `<your_api_key>` with the real one):

```
VITE_STREAM_API_KEY=<your_api_key>
```

With that the basic setup of the project and the Stream SDK is ready and we can dive into the code.

### User Authentication

We won't cover the entire flow of authentication in this guide because we want to focus on the important parts.
You can check the complete flow in the sample app repository, and we'll go through the important API calls now.

The first important step is to initialize the Stream client. Therefore, we need the API key and a token provider.

:::tip
Want to learn why we need the token provider and how it works? See [this page](../../guides/client-auth/#token-providers) for more detail.
:::

First, we can collect the API key from our `.env` file by simply importing it like this:

```
const apiKey = import.meta.env.VITE_STREAM_API_KEY as string;
```

Next, to get a token, we need to create one in our backend. Whenever this expires the SDK will call the token provider again to renew the token.
There are many different ways to solve this. In this example, we create (and - of course - memoize) a function that uses a `user` object in the same component.

```tsx
const tokenProvider = useCallback(async () => {
  const { token } = await fetch(
    '/api/auth/create-token?' +
      new URLSearchParams({
        api_key: apiKey,
        user_id: user.id,
      }),
    {},
  ).then((res) => res.json());
  return token as string;
}, [apiKey, user.id]);
```

Having this we can create a client object:

```tsx
const client = useCreateStreamVideoClient({
  apiKey,
  tokenOrProvider: tokenProvider,
  user,
});
```

Whenever a user hits the login button we can authenticate them using a call to `connectUser`:

```tsx
await client.connectUser(user, user.token);
```

For this to work we need a `User` object which is a simple typescript file with the following properties:

```ts
export interface User {
  id: string;
  name: string;
  imageUrl: string;
  token?: string;
}
```

With this, the user will be logged in and authenticated versus the Stream backend.

### Creating rooms via the API

Now that we have user authentication out of our way we can start building up our app.
The first thing we'll do is to allow users to create an audio room where others can then join.

The data model for this needs a few properties. Create a new Typescript file, call it `AudioRoom` and fill it up with this:

```ts
export interface AudioRoom {
  id: string;
  title: string;
  subtitle: string;
  hosts: User[];
  speakers: User[];
  listeners: User[];
  call?: Call;
}
```

Each room will need to have a unique `id` so that it can be identified clearly. It also needs a `title`, and a `subtitle` describing the topic.
These can be gathered through a simple form (find our example [here](TODO: add link) if interested).

We already created the `User` object earlier. We will have 3 different roles in our rooms:

1. `hosts`: they are allowed to start and end rooms; they can also promote `listeners` to the `speakers` roles
2. `speakers`: with that role comes the ability to broadcast audio in the call
3. `listeners`: can join the call and listen but not share their audio; they can ask for permission to speak

The last object in our type is the `Call` itself which is the Stream object with all the attached logic.

Now, after collecting the necessary info (`title` and `description`, maybe a list of hosts) we can create a call on the backend using the following call:

```ts
const randomId = Math.random().toString(36).substring(2, 12);
// highlight-next-line
const call = client?.call('audio_room', randomId);
call?.getOrCreate({
  data: {
    // highlight-next-line
    members: [{ user_id: user?.id || '', role: 'admin' }],
    custom: {
      // highlight-start
      audioRoomCall: true,
      title: title,
      description: description,
      hosts: [
        {
          name: user?.name,
          id: user?.id,
          imageUrl: user?.imageUrl,
        },
      ],
    },
    // highlight-end
  },
});
```

Let's unpack what's happening here step-by-step.

First, we create a random string and call it `randomId` for the call id.

Then, a new call is created with the `id` and the `audio_room` type. This is a short call but under the hood
does a great amount of configuration. It creates all the necessary settings for the call to allow users
to ask for speaking rights, be audio only, and allow all registered users to join calls (without the ability
to speak per default).

:::note
You can read more on the different call types that we offer and how to configure your own on the `Call Types` [page](../../guides/10-configuring-call-types).
:::

Next, we'll make sure the current user (and others who should have hosting rights) is part of the `members` object.
This is needed to provide them with the necessary admin rights to start/end calls and promote users.

Finally, the `custom` field can be used to add our - well - custom data to the call. We add an `audioRoomCall` variable in there
to identify the calls we want to use (important if we would have other call types in the future).
The rest of this object just contains the data we previously defined so that we can have it available to modify and update.

### Querying calls (with watch)

One of the main screens of the application will be showing a list of the rooms that are available for users to join.

To do this we need to query the backend for a list of the calls and display each of the rooms. Again, we'll not focus on the UI
part since that's different for each use case.

So, let's assume we have a component that stores the rooms in a `rooms` array, so let's define that at the root of the component:

```
const [rooms, setRooms] = useState<AudioRoom[]>([]);
```

Next, querying is fairly easy. Here is the code and we'll go through it afterwards:

```tsx
const client = useStreamVideoClient();
useEffect(() => {
  console.log('Loading calls');
  client
    ?.queryCalls({
      filter_conditions: { audioRoomCall: true },
      sort: [],
      watch: true,
    })
    .then((result) => {
      console.log('Querying calls successful.');
      setRooms(result.calls);
    })
    .catch((err) => {
      console.log('Querying calls failed.');
      console.error(err);
    });
}, [client, setRooms]);
```

We need a reference to the `client` which we conveniently can get with the `useStreamVideoClient` hook.
Then, we call the `.queryCalls` function in a `useEffect` hook. We can specify three things there:

1. `filter_conditions`: we want to only have calls with the `audioRoomCall` property set to true (which we specified earlier)
2. `sort`: we _could_ sort the calls we receive by some logic we want, for simplicity reasons we don't do this here
3. `watch`: this simple, but powerful property gives us the power to listen to real-time changes; whenever a call changes (for example going live) we'll get notified, and our rooms list updates

With that, we're ready to show the list of rooms. You can define that as you like, our example can be found [here](TODO: provider link to `RoomOverview` file).

### Joining and leaving a room

## Outline

- describe the project
- basic setup of the project
- logging users in
- creating a room
- querying calls with the data that is being set
- show an overview of the rooms
- enter/join a room and show the UI
