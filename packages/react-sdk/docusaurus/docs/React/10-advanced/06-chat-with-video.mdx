---
title: Chat Integration
description: How to integrate chat & video
---

In this tutorial we will guide you through the process of embedding video calling capabilities into a chat application. We will cover the following topics:

- Boilerplate setup (clients instantiation, building blocks)
- Initiating a ring call
- Handling different call calling states (ringing, active call, call left etc.)
- Handling different ring call events (call created, accepted, rejected and ended)
- Handling multiple pending calls
- Initiating group calls
- Terminating a call (pending, active)

## Project setup and prerequisites

Make sure you have the following prerequisites checked:

1. Register for a Stream account
2. Have an app created in the Stream's dashboard to obtain app API key and secret.
3. Initiate the project (you can follow our [introductory tutorial setup guide](../../basics/01-tutorial#set-up-for-success))
4. Have installed the Stream video and chat SDKs:

```shell
npm install @stream-io/video-react-sdk stream-chat-react stream-chat
```

```shell
yarn add @stream-io/video-react-sdk stream-chat-react stream-chat
```

:::important
When implementing a ring call scenario as we do in this demo, it is important to have a good understanding of our **ring call lifecycle**. You can learn more about the topic on the [doc page dedicated to call lifecycles](../02-call-lifecycle#ring-call).
:::

## App boilerplate

We have prepared a demo application to accompany this guide. We do not aim to explain the whole demo application source code. The demo application will serve us to demonstrate the main concepts behind the video in chat integration.

:::note
To initiate chat and video clients you are encouraged to use the same API key. The user tokens should be generated with the same secret. **There is no need to create separate apps for chat and video.**
:::note

## Initiating chat and video clients

Both clients are initiated using React hooks. The video SDK ships with hook [`useCreateStreamVideoClient`](../../call-engine/hooks-and-contexts#usecreatestreamvideoclient) and the hook [`useCreateChatClient`](https://github.com/GetStream/stream-video-js/tree/main/sample-apps/react/messenger-clone/src/hooks/useCreateChatClient.ts) is implemented specifically for this demo app. Both hooks make sure that potentially WS reconnections do not occur until the previous connection has been terminated.

:::warning
The UI should not be rendered until the chat client's WS connection is in place. Hook `useCreateChatClient` handles this by setting the chat client instance only after connection has been established.
:::

```tsx
import type { UserResponse } from 'stream-chat';
import { Chat } from 'stream-chat-react';
import {
  StreamVideo,
  useCreateStreamVideoClient,
} from '@stream-io/video-react-sdk';
import { Channel } from './components/Channel';
import { Sidebar } from './components/Sidebar';
import { Video } from './components/Video';
import { useCreateChatClient } from './hooks';

import type { StreamChatType } from './types/chat';

const Root = ({
  apiKey,
  user,
  userToken,
}: {
  apiKey: string;
  user: UserResponse<StreamChatType>;
  userToken: string;
}) => {
  const chatClient = useCreateChatClient<StreamChatType>({
    apiKey,
    tokenOrProvider: userToken,
    userData: user,
  });
  const videoClient = useCreateStreamVideoClient({
    apiKey,
    tokenOrProvider: userToken,
    user,
  });

  if (!chatClient) return null;

  return (
    <Chat client={chatClient}>
      <StreamVideo client={videoClient}>
        <Sidebar user={user} />
        <Channel />
        <Video />
      </StreamVideo>
    </Chat>
  );
};
```

## Initiating a ring call

In the ring call scenario we recommend to first create a call without immediately joining it. Use the `Call` method [`getOrCreate()`](../../call-engine/Call#getorcreate) to accomplish this. An example can be found in [`CreateCallButton` component](https://github.com/GetStream/stream-video-js/tree/main/sample-apps/react/messenger-clone/src/components/CreateCallButton/CreateCallButton.ts) in the demo app:

```tsx
import { useCallback } from 'react';
import {
  MemberRequest,
  useStreamVideoClient,
} from '@stream-io/video-react-sdk';
import { useChannelStateContext, useChatContext } from 'stream-chat-react';
import { LocalPhone } from '@mui/icons-material';
import { meetingId } from '../../utils/meetingId';
import type { StreamChatType } from '../../types/chat';

export const CreateCallButton = () => {
  const videoClient = useStreamVideoClient();
  const { client } = useChatContext<StreamChatType>();
  const { channel } = useChannelStateContext<StreamChatType>();

  const createCall = useCallback(() => {
    videoClient?.call('default', meetingId()).getOrCreate({
      // We set ring flag to opt into ring call lifecycle
      // highlight-next-line
      ring: true,
      data: {
        custom: {
          channelId: channel.id,
        },
        // include all channel members in the call
        members: Object.values(channel.state.members).reduce<MemberRequest[]>(
          (acc, member) => {
            if (member.user_id !== client.user?.id) {
              acc.push({
                user_id: member.user_id!,
              });
            }
            return acc;
          },
          [],
        ),
      },
    });
  }, [videoClient, channel.id, channel.state.members, client.user?.id]);

  const disableCreateCall = !videoClient;
  return (
    <button
      className="rmc__button rmc__button--green"
      disabled={disableCreateCall}
      onClick={createCall}
    >
      <LocalPhone />
    </button>
  );
};
```

:::note
There is a flexibility in what channel members will be included in the call. And so the call can be a 1:1 or a group call. In our implementation we include all channel members.
:::

## Handling the ring call states

Once a ring call is initiated, call members start to receive ring call events (`call.created`, `call.accepted`, `call.rejected`, `call.ended`) over the WebSocket maintained by the video client. The video client updates the **calls pool** state and [**calling state**](../../call-engine/hooks-and-contexts#usecallcallingstate) of individual affected [`Call`](../../call-engine/Call) in response to these events.

### Observing the calls pool state

The array of all [`Call`](../../call-engine/Call) objects representing created pending (not accepted, rejected, neither ended) calls is continuously updated in response to each new call creation. You can use this array of [`Call`](../../call-engine/Call) objects to display **incoming** or **outgoing calls** in your application's UI. **To identify an outgoing call**, use the [`Call.isCreatedByMe`](../../call-engine/Call#iscreatedbyme) flag.

In our demo app, we reflect the incoming calls state in channel list. Channel preview shows buttons to accept or reject the incoming call:

**todo: screenshot incoming calls in channel list (useCalls)**

**todo: code snippet of ChannelPreview**

The outgoing call is represented by a `CallPanel` component floating above the chat UI.

**todo: screenshot outgoing call**

**todo: code snippet outgoing call panel**

### Observing the state of a specific call

Each call can pass through different states as already described in the [Calling state section](../../guides/02-call-lifecycle#call-calling-state) of the call lifecycle documentation. The call calling state is made available through [`useCallCallingState` hook](../../call-engine/hooks-and-contexts#usecallcallingstate). Therefore, our `CallPanel` component displays different UI based on the information provided by the hook:

**todo: CallPanel code snippet.**

## Terminating a call

What call termination means depends on the perspective:

1. A user can reject an incoming call.
2. A user can end own outgoing call.
3. A call participant (who joined a call) can leave a call.

In case of the group call scenario, a single user rejecting an incoming call or participant leaving a call does not terminate the call for anybody else. A user who rejected or left a call can re-join the same call again. The call cannot be re-joined only if [ended](../02-call-lifecycle/#3-client-a-cancels-the-call). The ring call is not terminated automatically if a single participant is left in the call.
