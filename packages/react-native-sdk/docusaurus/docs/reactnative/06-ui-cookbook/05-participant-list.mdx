---
id: participant-list
title: Custom Participants List layout
---
import FinalLayout1 from '../assets/06-ui-cookbook/05-participant-list/01-final-layout.png';
import FinalLayout2 from '../assets/06-ui-cookbook/05-participant-list/02-final-layout.png';

## Introduction

The purpose of this guide is to help developers understand how to build a custom call participant list layout
using Stream React Native Video SDK. The guide will cover the necessary steps to connect to Stream's edge infrastructure,
join a call, and build the layout.

## About the sample application

To demonstrate the flexibility of our React Native Video SDK, we are going to build a custom "Zoom Speaker View"-like layout.
The app boilerplate can be found [here](https://github.com/GetStream/stream-video-js/tree/main/sample-apps/react-native/cookbook/).

This application allows a user to join a call by providing the call ID and type.
Once joined in a call, the user would be able to mute/unmute their audio and video and
display the video streams of all participants in a "Zoom Speaker View"-like layout.

The final layout looks like this:

| Layout when screen is shared | Call Layout |
| :--- | :--- |
| <img src={FinalLayout1} /> | <img src={FinalLayout2} /> |

## Prerequisites

Before we can join a call, we need to connect to Stream's edge infrastructure.
In order to do that, please follow these steps:

- Register for a Stream account and obtain your API key and secret.
- To install the Stream React Native Video SDK and it's dependencies follow this [guide](01-basics/03-installation.mdx).

We will start by creating our root component where we will initialize the Stream Video SDK and connect to Stream's edge infrastructure.
We will wrap our root component with the `StreamVideo` component and pass the `videoClient` instance to it.
This will ensure that the `videoClient` instance, among other APIs (see explanation below) will be available to all the components in the component tree.

```tsx
import { useCreateStreamVideoClient } from '@stream-io/video-react-sdk';
import { StreamVideo } from '@stream-io/video-react-native-sdk';
// This is the component that will render the custom layout.
// we can assume that the implementation of this component is empty for now.
import { MyActiveCall } from './MyActiveCall';

// Create a user object with the user ID and token and other information.
const USER = {
  id: STREAM_USER_ID,
  name: 'Alice',
  imageUrl: 'https://randomuser.me/api/portraits/women/65.jpg',
  custom: {
    token: STREAM_USER_TOKEN,
  },
};

export default () => {
  // Create a StreamVideoClient instance using the useCreateStreamVideoClient hook.
  const videoClient = useCreateStreamVideoClient({
    user: USER,
    tokenOrProvider: USER?.custom?.token,
    apiKey: STREAM_API_KEY,
  });

  return (
    // Wrap the MyActiveCall component with the StreamVideo component.
    // StreamVideo will provide the necessary context (client, callCycleHandlers,
    // device info and other relevant information about your calls) to the MyActiveCall component.
    <StreamVideo client={videoClient}>
      <MyActiveCall />
    </StreamVideo>
  );
};

```

## Joining a Call

To join a call, we need to know its ID and type. The call ID and type can come from any source you like.

In our example, we are going to hard code the call ID and type, but you can use any other method that will suit your business logics to get this information.

```tsx
import React, {useEffect} from 'react';
import {usePublishStreams, useStreamVideoClient } from '@stream-io/video-react-native-sdk';
import InCallManager from 'react-native-incall-manager';
import { View, Text } from 'react-native';


const CALL_ID = 'some-call-id';

const MyActiveCall = () => {
  // Get the videoClient instance from the context.
  const videoClient = useStreamVideoClient();
  // Start publishing the local audio and video streams.
  usePublishStreams();

  // Join the call when the component is mounted.
  useEffect(() => {
    const startCall = async ()=> {
      try {
        // Join the call and start the call cycle.
        await videoClient?.call('default', CALL_ID).join();
        // Start InCallManager and enable the speakerphone.
        InCallManager.start({media: 'video'});
        InCallManager.setForceSpeakerphoneOn(true);
      } catch (e) {
        console.log('Error joining call', e);
      }
    };
    startCall();
  }, []);

  return (
    <View>
      <Text>Call is active, rest will be implemented soon...</Text>
    </View>
  );
};
```

Behind the scenes, by calling `ideoClient?.call('default', CALL_ID).join()` a new [Call](../04-call-engine/Call.md) instance will be created and the connected user will join the call automatically.
The active call instance will be exposed down in the component tree through a React Context in the [CallState](../04-call-engine/contexts.md/#streamcallprovider) object.

You can read more about this mechanism as part of our [React Bindings and Hooks documentation](../04-call-engine/01-overview.gen.mdx).

## Building the Layout

Now that we have successfully set up the React Native Video SDK and joined the call, we can start building our custom layout.
For that purpose, we are going to utilize some fundamental React Video SDK components and hooks.

- [`<ParticipantView />`](../03-ui/components.md#participantview) - A component that renders a video stream of a participant.
- [`useCall()`](../04-call-engine/contexts.md#usecall) - A hook that returns the current call instance. You can use this hook to access the call state and call methods.
- [`useParticipants()`](../04-call-engine/hooks.md#useparticipants) - A hook that returns the list of all participants in the call.
- [`useDominantSpeaker()`](../04-call-engine/hooks.md#usedominantspeaker) - A hook that returns the current dominant speaker in the call.

On top of these hooks, we are going to apply some custom participant sorting logic:

- Dominant Speaker will take the largest space in the layout.
- The rest of the participants will be sorted at the top of the screen according to the following criteria:
  - Participants with screen-share will be displayed first
  - Participants with audio and video will be displayed next
  - Followed by video-only participants
  - Followed by audio-only participants
  - Muted participants will be displayed last

Having the rules set, let's go and implement the sorting:

### Determine the Dominant Speaker

In some circumstances, the dominant speaker might not be present in the list of participants.
In that case, we heuristically determine the dominant speaker by looking at the participants and we try to
pick one who is either sharing their screen or has both audio and video enabled.

Let's start by creating some utility functions that will help us determine the participant's state:
```tsx
import {
  SfuModels,
  StreamVideoParticipant,
} from '@stream-io/video-react-native-sdk';

export const hasScreenShare = (p: StreamVideoParticipant) =>
  p.publishedTracks.includes(SfuModels.TrackType.SCREEN_SHARE);

export const hasVideo = (p: StreamVideoParticipant) =>
  p.publishedTracks.includes(SfuModels.TrackType.VIDEO);

export const hasAudio = (p: StreamVideoParticipant) =>
  p.publishedTracks.includes(SfuModels.TrackType.AUDIO);
```


Now let's introduce our first custom hook `useSpotlightParticipant`:

```tsx
import {useMemo} from 'react';
import {
  useDominantSpeaker,
  useParticipants,
} from '@stream-io/video-react-native-sdk';
import {hasAudio, hasScreenShare, hasVideo} from './utils';

/**
 * Returns the participant to be shown in the spotlight.
 * Usually this is the dominant speaker, but if there is no dominant speaker,
 * then it's the first participant with screen share or video and audio.
 */
export const useSpotlightParticipant = () => {
  const participants = useParticipants();
  const dominantSpeaker = useDominantSpeaker();
  return useMemo(() => {
    return (
      dominantSpeaker ||
      participants.find(
        p => hasScreenShare(p) || (hasVideo(p) && hasAudio(p)),
      ) ||
      participants[0]
    );
  }, [participants, dominantSpeaker]);
};
```

### Sort the other participants

Now that we have the dominant speaker, we can sort the rest of the participants.
Similar to the spotlight participant, we are going to use a custom hook to encapsulate the sorting logic:

```tsx
import {useParticipants} from '@stream-io/video-react-native-sdk';
import {useSpotlightParticipant} from './useSpotlightParticipant';
import {hasAudio, hasScreenShare, hasVideo} from './utils';

/**
 * Sorts participants so that:
 * - the presenter is first,
 * - the dominant speaker is next,
 * - then video, then audio, then the rest.
 */
export const useSortedParticipants = () => {
  const participantInSpotlight = useSpotlightParticipant();
  // we filter out the participant in spotlight if they are not sharing screen
  const allParticipants = useParticipants();
  const participants = allParticipants.filter(p => {
    return (
      hasScreenShare(participantInSpotlight) || p !== participantInSpotlight
    );
  });

  const presenters = participants.filter(p => hasScreenShare(p));
  const videoAndAudioParticipants = participants.filter(
    p => hasVideo(p) && hasAudio(p),
  );
  const videoOnlyParticipants = participants.filter(
    p => hasVideo(p) && !hasAudio(p),
  );
  const audioOnlyParticipants = participants.filter(
    p => !hasVideo(p) && hasAudio(p),
  );
  const muteParticipants = participants.filter(
    p => !hasVideo(p) && !hasAudio(p),
  );

  return [
    participantInSpotlight,
    ...presenters,
    ...videoAndAudioParticipants,
    ...videoOnlyParticipants,
    ...audioOnlyParticipants,
    ...muteParticipants,
  ];
};
```

### Create your custom call participants view

Now that we have all the data we need, organized in the way we want, we can render the layout in a new component `MyCallParticipantsView`:

```tsx
import {ParticipantView} from '@stream-io/video-react-native-sdk';
import {useSortedParticipants} from './useSortedParticipants';
import {FlatList, StyleSheet, View} from 'react-native';
import {StreamVideoParticipant} from '@stream-io/video-client';
import {hasScreenShare} from './utils';
import {useConnectedUser} from '@stream-io/video-react-bindings';

export const MyCallParticipantsView = () => {
  // we use the custom hook we've just built to get the sorted participants
  const [participantInSpotlight, ...otherParticipants] =
    useSortedParticipants();
  // we use the built-in hook to get the current user
  const connectedUser = useConnectedUser();

  const renderItem = ({item: participant}: {item: StreamVideoParticipant}) => {
    return (
      // we use the built-in ParticipantView component to render the participant
      <ParticipantView
        participant={participant}
        containerStyle={[styles.baseParticipant, styles.participant]}
        // we disable playing the audio of the current user
        disableAudio={participant.userId === connectedUser?.id}
        kind="video"
      />
    );
  };

  return (
    <View style={styles.container}>
      {/*we render the participant in spotlight in a separate view.*/}
      {participantInSpotlight && (
        <ParticipantView
          participant={participantInSpotlight}
          containerStyle={[styles.baseParticipant, styles.spotlightParticipant]}
          kind={hasScreenShare(participantInSpotlight) ? 'screen' : 'video'}
          disableAudio={participantInSpotlight.userId === connectedUser?.id}
        />
      )}
      <View style={styles.participantVideoContainer}>
        {/*render remaining participants on the lower part of the screen in an horizontal FlatList.*/}
        <FlatList<StreamVideoParticipant>
          data={otherParticipants}
          keyExtractor={item => item.sessionId}
          renderItem={renderItem}
          horizontal
          showsHorizontalScrollIndicator={false}
        />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  participantVideoContainer: {
    paddingVertical: 16,
  },
  baseParticipant: {
    marginHorizontal: 8,
    overflow: 'hidden',
    borderRadius: 10,
  },
  spotlightParticipant: {
    flex: 1,
  },
  participant: {
    width: 150,
    height: 150,
  },
});
```

### Render it all together
Now we're ready to continue with the implementation of the `MyActiveCall` component from the previous [step](#joining-a-call).
```tsx
import {ActivityIndicator, StyleSheet, View} from 'react-native';
import React, {useEffect} from 'react';
import {CallControlsView, StreamCallProvider, useActiveCall, usePublishStreams, useStreamVideoClient, } from '@stream-io/video-react-native-sdk';
import InCallManager from 'react-native-incall-manager';
// import the custom call participants view that we've just built
import {MyCallParticipantsView} from './MyCallParticipantsView';


const CALL_ID = 'some-call-id';

const MyActiveCall = () => {
  // Get the videoClient instance from the context.
  const videoClient = useStreamVideoClient();
  // Start publishing the local audio and video streams.
  usePublishStreams();
  // Get the active call from the context.
  const activeCall = useActiveCall();

  // Join the call when the component is mounted.
  useEffect(() => {
    const startCall = async ()=> {
      try {
        // Join the call and start the call cycle.
        await videoClient?.call('default', CALL_ID).join();
        // Start InCallManager and enable the speakerphone.
        InCallManager.start({media: 'video'});
        InCallManager.setForceSpeakerphoneOn(true);
      } catch (e) {
        console.log('Error joining call', e);
      }
    };
    startCall();
  }, []);

  if (!activeCall) {
    return <ActivityIndicator size={'large'} style={StyleSheet.absoluteFill} />;
  }

  return (
    <StreamCallProvider call={activeCall}>
      <View style={styles.wrapper}>
        {/*render the custom call participants view that we've just built*/}
        <MyCallParticipantsView />
        {/*render the built-in call controls view (containing mute/hangup/toggle camera buttons etc.)*/}
        <CallControlsView
          onHangupCall={() => {
            // You can use this callback to navigate back to your previous/home screen for instance.
            return;
          }}
        />
      </View>
      }
    </StreamCallProvider>
  );
};

const styles = StyleSheet.create({
  wrapper: {
    flex: 1,
    backgroundColor: '#272A30',
  },
});
```

Et voilà, we have successfully built our custom layout.
At last, you can find the running example of this guide [here](https://github.com/GetStream/stream-video-js/sample-apps/react-native/cookbook/).

## Further customization

The React Native Video SDK is built on top of the data model that our [call engine](../04-call-engine/01-overview.gen.mdx) exposes.
As such, you can use the same data model to build your own custom layouts.

You can go further and build your own custom components, but we advise to at least use our base components and hooks to a certain extent.
Please make sure that you wouldn't have to re-implement some baked-in functionality like:
Simulcast, DynaScale, Track Subscription handling, muting/unmuting, etc.
