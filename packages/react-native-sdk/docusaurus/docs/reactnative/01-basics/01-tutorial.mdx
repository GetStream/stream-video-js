---
id: 01-tutorial
title: Tutorial
---

## Introduction

Hi there and welcome to our Stream Video React Native tutorial.

`StreamVideo` is an SDK that facilitates adding calling (audio and video) support to your apps. It's a performant and highly customizable, allowing you to build various types of calling applications and streaming use cases, such as:

- **Messenger-style applications**: These applications implement Chat as a primary source of communication, with Video secondary.
- **Meeting-style applications**: Such apps focus primarily on Video, with Chat as a way to communicate while in a call. Eg: Zoom, Google Meet, etc.
- **Audio Rooms**: Our SDK allows you to build audio-only rooms that allow live communication, such as Twitter Spaces.
- **Livestreaming**: We support one of the most popular modern use cases - streaming audio and video to audiences. You can replicate apps like Twitch or YouTube Live.

This makes the Stream Video SDK the best-in-class choice when integrating Audio and Video communication in your apps. With all that in mind, let's dive into the tutorial.

## Tutorial Contents

:::info
In the following tutorial we will focus on building a Meeting-style application, such as Zoom, Google Meet, etc.

If your app resembles a Ring-style application, such as Messenger, then please, follow the guide [Chat With Video](../../guides/06-chat-with-video/).
:::

We will explain how to integrate Stream Video to support Meetings in your Application.

In this tutorial, we are building a video call application using the Stream Video React SDK. We will be implementing a "Meeting Room" scenario, where users can join and leave the call independently, without causing the call to be terminated. The topics we are covering in this tutorial are:

- Setting up the project.
- Creating the call UI/screens using built-in components.
- Creating/Joining a new call.
- Leaving an existing call.
- View Participants info.

To get started with the guide, ensure you have set up your [development environment for React Native](https://reactnative.dev/docs/environment-setup). Stream Chat supports creating applications using Expo and React Native CLI. But Stream Video currently only supports React Native CLI, so we will only focus on React Native CLI in this documentation.

## Create a new project

Create a new RN project with TypeScript

```bash
npx react-native init StreamMeetingTutorial --template react-native-template-typescript
```

## Install dependencies and initial setup

Follow this [guide](01-basics/03-installation.mdx) to install the dependencies and setup the project.

## Creating and providing the Video Client

We will start by creating a simple video meeting with Stream's Video SDK.

### Create a StreamVideoClient

First things first we will create a `StreamVideoClient` that will be used to communicate to Stream's Video backend and create a new client.
This expects an API key as the first argument. It also expects `options`.

```tsx
import React from 'react';
import { StreamVideoClient } from '@stream-io/video-client';

const user = {
  id: 'micheal',
  name: 'Micheal',
  imageUrl: 'https://randomuser.me/api/portraits/men/44.jpg',
};
const USER_TOKEN = 'YOUR_TOKEN';
const API_KEY = 'YOUR_TOKEN';
const videoClient = new StreamVideoClient(API_KEY);
```

### Connecting and disconnecting from the video client

We will connect to the Stream's client instance we've created right after the component has mounted.
When the component un-mounts we will disconnect from the client.

```tsx
import React, {useEffect, useState} from 'react';
import {ActivityIndicator, SafeAreaView, StyleSheet} from 'react-native';

...
const App = () => {
  const [connected, setConnected] = useState(false);
  const [error, setError] = useState(undefined);

  useEffect(() => {
    const run = async () => {
      try {
        await videoClient.connect(user, USER_TOKEN);
        setConnected(true);
      } catch (err) {
        console.error('Failed to establish connection', err);
      }
    };
    run();

    return () => {
      videoClient.disconnect();
    };
  }, []);

  if (!connected) {
    return (
      <SafeAreaView style={{flex: 1}}>
        <ActivityIndicator size={'large'} style={StyleSheet.absoluteFill} />
      </SafeAreaView>
    );
  }

  return !error ? (
    <SafeAreaView style={{flex: 1}}>
      <Text>We're connected now and ready to go ðŸš€</Text>
    </SafeAreaView>
  ) : (
    <Text>{error}</Text>
  );
};
```

For simplicity, you can also use the `useCreateStreamVideoClient` [hook](../../call-engine/hooks#usecreatestreamvideoclient) to connect and disconnect from the client.

### Provide the video client logic to the rest of the app

Our `StreamVideoCall` component will provide our recently created video client to the rest of the underlying components.
The `client` created above can be used as follows and needs to be provided to the `client` prop of the `StreamVideoCall` component.

_Note: Make sure to wrap your entire application in `StreamVideoCall`._

```tsx title="App.tsx"
import React from 'react';
import {ActivityIndicator, StyleSheet} from 'react-native';
import {StreamVideoCall } from '@stream-io/video-react-native-sdk';
...

const App = () => {
  const {videoClient} = useCreateStreamVideoClient({
    user: user,
    tokenOrProvider: USER_TOKEN,
    apiKey: API_KEY,
  });

  if (!videoClient) {
    return <ActivityIndicator size={'large'} style={StyleSheet.absoluteFill} />;
  }

  return (
    <StreamVideoCall
      callId={'some-call-id'}
      client={videoClient}
  >
      {children}
    </StreamVideoCall>
  );
};
```

### Create global app state

In the following steps, we will need a global app state to store the `callId` and `CallType`.
This will allow us to share and change the `callParams` across the app.

```tsx title="AppContext.tsx"
import React, { PropsWithChildren, useState } from 'react';

type AppContextType = {
  callParams: { callId: string; callType: string };
  setCallParams: React.Dispatch<
    React.SetStateAction<{ callId: string; callType: string }>
  >;
};

// Create a context by using React's createContext method
export const AppContext = React.createContext({} as AppContextType);

export const AppProvider = ({ children }: PropsWithChildren<{}>) => {
  // Create a state to hold the call params
  const [callParams, setCallParams] = useState<{
    callId: string;
    callType: string;
  }>({
    callId: '',
    callType: 'default',
  });

  return (
    // Provide the call params to the rest of the app
    <AppContext.Provider
      value={{
        callParams,
        setCallParams,
      }}
    >
      {children}
    </AppContext.Provider>
  );
};

// Create a utility hook to easily consume the context
export const useAppContext = () => React.useContext(AppContext);
```

### Adding call cycle handlers

`StreamVideoCall` component has also a `callCycleHandlers` prop of type object that expects `onCallJoined` and `onCallHungUp`
handlers (among other handlers) to deal with transitions between the call states.
These handlers can be used to perform preperation/teardown tasks or navigation between screens.

An example can be seen below:

```tsx title="App.tsx"
import {StreamVideoCall } from '@stream-io/video-react-native-sdk';
import {useAppContext} from './AppContext';
...

const App = () => {
  ...
  const {
    callParams: {callId},
  } = useAppContext();

  return (
    <StreamVideoCall
      callId={callId}
      client={videoClient}
      callCycleHandlers={{
        onCallJoined: () => navigation.navigate('ActiveCallScreen'),
        onCallHungUp: () => navigation.navigate('JoinMeetingScreen'),
      }}>
      {children}
    </StreamVideoCall>
  );
};
```

## Planning the Screens

The app is supposed to have 4 screens each for entering meeting id, lobby view, active call and call participants info screen.
We use [react-navigation](http://reactnavigation.org/) to set up the navigator. To do this, we will firstly define the types.

```tsx title="src/types.ts"
export type NavigationStackParamsList = {
  CallLobbyScreen: { callId: string };
  ActiveCallScreen: undefined;
  CallParticipantsInfoScreen: undefined;
  JoinMeetingScreen: undefined;
};
```

Finally, set up the stack navigator and the stack screen.

```tsx title="App.tsx"
import React from 'react';
import {NavigationStackParamsList} from './src/types';
import {createNativeStackNavigator, NativeStackNavigationProp} from '@react-navigation/native-stack';
import {NavigationContainer, useNavigation} from '@react-navigation/native';
import {StreamVideoCall} from '@stream-io/video-react-native-sdk';
import {JoinMeetingScreen} from './src/screens/JoinMeetingScreen';
import {LobbyViewScreen} from './src/screens/LobbyViewScreen';
import {ActiveCallScreen} from './src/screens/ActiveCallScreen';
import {CallParticipansInfoScreen} from './src/screens/CallParticipantsInfoScreen';
import {AppProvider} from './AppContext';

const Stack = createNativeStackNavigator<NavigationStackParamsList>();

const UltimateRoot = () => {
  ...
  const navigation =
    useNavigation<NativeStackNavigationProp<NavigationStackParamsList>>();

  return (
    <StreamVideoCall
      callId={callId}
      client={videoClient}
      callCycleHandlers={{
        onCallJoined: () => navigation.navigate('ActiveCallScreen'),
        onCallHungUp: () => navigation.navigate('JoinMeetingScreen'),
      }}>
      <Stack.Navigator>
        <Stack.Screen
          name='JoinMeetingScreen'
          component={JoinMeetingScreen}
        />
        <Stack.Screen
          name='CallLobbyScreen'
          component={LobbyViewScreen}
        />
        <Stack.Screen
          name='ActiveCallScreen'
          component={ActiveCallScreen}
          options={{ headerShown: false }}
        />
        <Stack.Screen
          name='CallParticipantsInfoScreen'
          component={CallParticipansInfoScreen}
        />
      </Stack.Navigator>
    </StreamVideoCall>
  );
};

function App(): JSX.Element {
  return (
    <NavigationContainer>
      {/* Providing our app's global state*/}
      <AppProvider>
        {/*Root of our app*/}
        <UltimateRoot />
      </AppProvider>
    </NavigationContainer>
  );
}

export default App;
```

### Join Meeting screen

This screen is required to have a text input where the id of the meeting to be joined can be entered and a button to create/start the call.
We can use the create call button to show/navigate to LobbyView component/screen.
Our implementation of this screen is as follows:

```tsx title="src/screens/JoinMeetingScreen.tsx"
import React, { useCallback } from 'react';
import { Button, SafeAreaView, Text, TextInput, View } from 'react-native';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { NavigationStackParamsList } from '../types';
import { useAppContext } from './AppContext';

type JoinMeetingScreenProps = NativeStackScreenProps<
  NavigationStackParamsList,
  'JoinMeetingScreen'
>;

export const JoinMeetingScreen = (props: JoinMeetingScreenProps) => {
  const {
    setCallParams,
    callParams: { callId },
  } = useAppContext();
  const { navigation } = props;

  const joinCallHandler = useCallback(() => {
    navigation.navigate('CallLobbyScreen');
  }, [navigation]);

  return (
    <SafeAreaView>
      <View>
        <Text>{'Whats the call ID?'}</Text>
      </View>
      <TextInput
        value={callId}
        onChangeText={(text) =>
          setCallParams((prevState) => ({
            ...prevState,
            callId: text.trim().split(' ').join('-'),
          }))
        }
      />
      <Button
        title={'Create meeting with callID: ' + callId}
        color="blue"
        disabled={!callId}
        onPress={joinCallHandler}
      />
    </SafeAreaView>
  );
};
```

### Render the Lobby View component

To render the call lobby component, you can import `LobbyView` component from the Video SDK and use it
in the Screen/View. `LobbyView` component expects a meeting id that will be used to join the call.

```tsx title="src/screens/LobbyViewScreen.tsx"
import React from 'react';
import { ScrollView } from 'react-native';
import { LobbyView, theme } from '@stream-io/video-react-native-sdk';

export const LobbyViewScreen = () => {
  return (
    <ScrollView
      style={{ backgroundColor: theme.light.static_grey }}
      contentContainerStyle={styles.contentContainerStyle}
    >
      <LobbyView />
    </ScrollView>
  );
};

const styles = {
  contentContainerStyle: {
    paddingVertical: 16,
  },
};
```

### Rendering the Active call view

To render the active call view, you can import `ActiveCall` component from the Video SDK and use it in the
Screen/View where you want to render it. This component expects a handler to deal with the case of what should
happen when user clicks on the Participants View icon(`onOpenCallParticipantsInfoView`).

```tsx title="src/screens/ActiveCallScreen.tsx"
import React, { useCallback } from 'react';
import { ActiveCall, useCall } from '@stream-io/video-react-native-sdk';
import { ActivityIndicator, StyleSheet, View } from 'react-native';
import { NavigationStackParamsList } from '../types';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { theme } from '@stream-io/video-react-native-sdk/src/theme';

type ActiveCallScreenProps = NativeStackScreenProps<
  NavigationStackParamsList,
  'ActiveCallScreen'
>;

export function ActiveCallScreen({ navigation }: ActiveCallScreenProps) {
  const activeCall = useCall();
  const insets = useSafeAreaInsets();

  // Handler executed when the call participants icon is pressed. This is used to render CallParticipantsInfoView.
  const onOpenCallParticipantsInfoViewHandler = useCallback(() => {
    navigation.navigate('CallParticipantsInfoScreen');
  }, [navigation]);

  // Since the call takes time to join we show an ActivityIndicator until then.
  if (!activeCall) {
    return <ActivityIndicator size={'large'} style={StyleSheet.absoluteFill} />;
  }
  return (
    <View style={[styles.wrapper, { paddingTop: insets.top }]}>
      <ActiveCall
        onOpenCallParticipantsInfoView={onOpenCallParticipantsInfoViewHandler}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  wrapper: {
    flex: 1,
    backgroundColor: theme.light.static_grey,
  },
});
```

### Rendering the CallParticipantsInfoView component

To render the call participants info view, you can import `CallParticipantsInfoView` from the Video SDK and use it in the Screen/View where you want to render it.

```tsx title="src/screens/CallParticipansInfoScreen.tsx"
import React from 'react';
import { CallParticipantsInfoView } from '@stream-io/video-react-native-sdk';

export const CallParticipansInfoScreen = () => {
  return <CallParticipantsInfoView />;
};
```

## Further Integration

Congratulations on completing this tutorial. You've learned how to build two very popular use cases - Meeting and Ringing Calls. However, our SDK supports multiple other use cases and more advanced features. If you're looking to integrate more of our supported functionality, we recommend checking out the following guides:

[//]: # '* [guide](05-advanced/02-push-notification/01-overview.mdx)'

(../02-guides/05-socket-events.mdx)

- [Call Lifecycle](../02-guides/02-call-lifecycle.mdx): It's important to understand the lifecycle of our SDK and Calls to properly build complex use cases for your users.
- [Call Engine](../02-guides/03-call-engine.mdx): If you're looking to utilize our state machine to the fullest, explore what our internal CallEngine does and how to listen to state.
- [Deep linking](../05-advanced/01-deeplinking.mdx): Deep linking is very useful for Meeting apps where you can simply send a link for the Call that lets people join.
- [Push Notifications](../05-advanced/02-push-notifications.mdx): Apps where Ring people and invite them to Calls heavily rely on push notifications. Learn how to integrate them with our SDK.

Alternatively, if you're modeling your app based on popular apps, like Messenger, Telegram, Zoom, Google Meet, Twitter Spaces or Twitch, we have several guides and template projects prepared for you:

- [Chat + Video](../02-guides/06-chat-with-video.mdx): Messenger and Telegram like applications feature Chat as a primary source of communication, with Video being secondary. To build a similar app, follow our Chat + Video guide that provides you with a template project to kick start your app, with all the UI and setup pre-baked.
- [Audio Rooms](../02-guides/07-audio-rooms.mdx): Some apps feature live audio rooms where people gather to discuss ideas and fun topics. Apps like Twitter Spaces are popular and you can build them using our Audio Rooms guide. It also prepares a template project for you that cuts the time you need to start working on your app.
- [Livestream](../02-guides/08-livestream.mdx): Last, but not least, our Livestream guide teaches you how to build an app where one person streams their tracks to a group of people in real time. By the end of the guide, you'll have a project that prepares most of the setup for you.
