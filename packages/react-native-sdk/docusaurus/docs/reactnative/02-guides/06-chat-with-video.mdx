---
id: 06-chat-with-video
title: Chat with Video
---

## Building Chat Apps With Video Support

One of the most common chat app use cases is having a chat feature in your app that allows users to
engage in audio and video communication. This direct integration allows for simple transition between
text and images to more complex media.

Stream supports this use case, out-of-the-box.
In this guide, you'll walk through all the steps required to integrate our Chat and Video React Native SDKs into a cohesive whole.
You'll cover the following:

- Creating a Chat app.
- Adding Stream dependencies.
- Creating Stream Chat and Video client.
- Authenticating Chat and Video users.
- Building custom Call attachments and "Start Call" UI.

By the end of this guide, your app will look like this:

[//]: # 'todo: add a screenshot'

You'll have the ability to create messaging conversations, in which you can start calls as a custom attachment.
Anyone in the chat will then be notified accordingly and can join the call.

Let's see how to implement this.

## Prepare your development environment on your machine

To get started with the guide, ensure you have set up your [development environment for React Native](https://reactnative.dev/docs/environment-setup).
Stream Chat supports creating applications using Expo and React Native CLI. But Stream Video currently only supports React Native CLI, so we will only focus on React Native CLI in this documentation.

## Creating the chat project

The easiest way to get a chat project up and running can be done by using the [Chat Starter Kit Template](https://github.com/GetStream/react-native-stream-chat-template#react-native-stream-chat-template) or to
follow [React Native Chat Tutorial](https://getstream.io/chat/react-native-chat/tutorial/) first and get a basic chat screens ready in your app.

## Install dependencies and initial setup

Follow this [guide](01-basics/03-installation.mdx) to install the dependencies and setup the project.

### Creating and Providing the Video Client

Firstly we need to authenticate the Video SDKâ€™s Client.

#### Creating the client

You will need a user and token to authenticate a client.
You can use the `client` from the Chat SDK to create the user object.
To do this, you can import the hook, `useChatContext`, and use the `client` from it to create the user, as in the example below.
To create a client, we can use `StreamVideoClient` class that will be used to communicate to Stream's Video backend and create a new client.
The `StreamVideoClient` is internally responsible to create a client, connect with the user and cleanup when the component is unmounted.

```tsx title="src/components/VideoWrapper.tsx"
import { useMemo, useState, useEffect } from 'react';
import { useChatContext } from 'stream-chat-react-native';
import { StreamVideoClient } from '@stream-io/video-react-native-sdk';

// Inside your component
const [videoClient, setVideoClient] = useState<StreamVideoClient | undefined>(
  undefined,
);
const { client: chatClient } = useChatContext();
const token = chatClient._getToken() ?? `Your Token`;
const STREAM_API_KEY = 'YOUR API KEY';

const user = useMemo(
  () => ({
    id: client.user?.id as string,
    name: client.user?.name as string,
    imageUrl: client.user?.image as string,
  }),
  [chatClient.user],
);

//fetch the token
useEffect(() => {
  const _videoClient = new StreamVideoClient({
    apiKey: STREAM_API_KEY,
    user,
    tokenProvider,
  });
  setVideoClient(_videoClient);

  return () => {
    _videoClient.disconnectUser();
    setVideoClient(undefined);
  };
}, [tokenProvider, user]);
```

#### Providing the client

Our `StreamVideo` component will provide our recently created video client to the rest of the underlying components.
The `videoClient` created above can be used as follows and needs to be provided to the `client` prop of the `StreamVideo` component.

```tsx title="src/components/VideoWrapper.tsx"
import React from 'react';
import { ActivityIndicator } from 'react-native';
import { StreamVideo } from '@stream-io/video-react-native-sdk';
...

const VideoWrapper = () => {
  ...
  if (!videoClient) {
    return <ActivityIndicator size={'large'} style={StyleSheet.absoluteFill} />;
  }

  return <StreamVideo client={videoClient}>{children}</StreamVideo>;
};
```

### Creating and Providing the call

In the case of call flow, we get all the created or incoming calls through the hook `useCalls`.
This hook can be used to retrieve the call details and pass it to the StreamCall component.

```tsx
import { useCalls, StreamCall } from '@stream-io/video-react-native-sdk';

export const Calls = () => {
  const calls = useCalls();
  const callCycleHandlers = {};

  return (
    <>
      {calls.map((call) => {
        return (
          <StreamCall
            key={call.cid}
            call={call}
            callCycleHandlers={callCycleHandlers}
          ></StreamCall>
        );
      })}
    </>
  );
};
```

### Adding the Call Cycle handlers

`StreamCall` component has also a `callCycleHandlers` prop of type object that expects `onCallJoined`, `onCallHungUp` and `onCallJoining`, `onCallIncoming`, `onCallOutgoing` and `onCallRejected` handlers to deal with transitions between the call states.
These handlers can be used to perform preparation/teardown tasks or navigation between screens.

- `onCallJoined` callback that is called after the user joins the call.
- `onCallHungUp` callback that is called after the user hangs up the call.
- `onCallIncoming` callback that is called when a callee receives an incoming call.
- `onCallOutgoing` callback that is called after a caller creates an outgoing call.
- `onCallRejected` callback that is called after a callee rejects an incoming call.

An example can be seen below:

```tsx
import React, { useCallback, useState, useMemo } from 'react';
import { useCalls, StreamCall } from '@stream-io/video-react-native-sdk';

type ScreenTypes = 'incoming' | 'outgoing' | 'active-call' | 'joining' | 'none';

export const Calls = () => {
  const calls = useCalls();
  const [show, setShow] = useState<ScreenTypes>('none');

  const onCallJoined = useCallback(() => {
    setShow('active-call');
  }, [setShow]);

  const onCallIncoming = useCallback(() => {
    setShow('incoming');
  }, [setShow]);

  const onCallOutgoing = useCallback(() => {
    setShow('outgoing');
  }, [setShow]);

  const onCallHungUp = useCallback(() => {
    setShow('none');
  }, [setShow]);

  const onCallRejected = useCallback(() => {
    setShow('none');
  }, [setShow]);

  const callCycleHandlers = useMemo(() => {
    return {
      onCallJoined,
      onCallIncoming,
      onCallOutgoing,
      onCallHungUp,
      onCallRejected,
    };
  }, [
    onCallJoined,
    onCallIncoming,
    onCallOutgoing,
    onCallHungUp,
    onCallRejected,
  ]);

  return (
    <>
      {calls.map((call) => {
        return (
          <StreamCall
            key={call.cid}
            call={call}
            callCycleHandlers={callCycleHandlers}
          ></StreamCall>
        );
      })}
    </>
  );
};
```

### Rendering the IncomingCallView, OutgoingCallView, ActiveCall components

To render the incoming call view, outgoing call view component and active call components, you can import `IncomingCallView`, `OutgoingCallView` and `ActiveCall` component from the Video SDK and use it
in the Screen/View.

An example is shared below:

```tsx
import React from 'react';
import {
  ActiveCall,
  IncomingCallView,
  OutgoingCallView,
} from '@stream-io/video-react-native-sdk';
import { StyleSheet, View, ActivityIndicator } from 'react-native';

const CallPanel = ({ show }: { show: ScreenTypes }) => {
  switch (show) {
    case 'incoming':
      return <IncomingCallView />;
    case 'outgoing':
      return (
        <View style={styles.container}>
          <OutgoingCallView />
        </View>
      );
    case 'active-call':
      return (
        <View style={styles.container}>
          <ActiveCall />
        </View>
      );
    case 'joining':
      return (
        <View style={styles.container}>
          <ActivityIndicator size={'large'} style={StyleSheet.absoluteFill} />
        </View>
      );
    case 'none':
      return null;
    default:
      return null;
  }
};

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: theme.light.static_grey,
  },
});
```

This `CallPanel` component can be passed as a children to the `StreamCall` component above.

```tsx
export const Calls = () => {
  ...

  return (
    <>
      {calls.map((call) => {
        return (
          <StreamCall
            key={call.cid}
            call={call}
            callCycleHandlers={callCycleHandlers}
          >
            <CallPanel show={show}/>
          </StreamCall>
        );
      })}
    </>
  );
};
```

### Creating the call

To create a call, we will use the `call` method of the video client that we created before.
To start a ring call we use the `getOrCreateCall` function from the call instance.
This function expects a `members` to whom we want to call and a `ring` `boolean` to indicate that we want to have a ring call.

An example of the usage is shared below:

```tsx
import React, { useCallback } from 'react';
import { useAppContext } from '../context/AppContext';
import { useStreamVideoClient } from '@stream-io/video-react-native-sdk';
import { useChatContext } from 'stream-chat-react-native';

// Inside the component in which you will trigger the call.
// The channel is retrieved from the App Context. Please refer the chat tutorial for more info.
const { channel } = useAppContext();
const videoClient = useStreamVideoClient();
const members = Object.values(channel?.state?.members ?? {}).map<MemberRequest>(
  (member) => ({
    user_id: member.user_id!,
  }),
);

const joinCallHandler = useCallback(async () => {
  try {
    const callType = 'default';
    const callId = 'some-random-unique-call-id';
    const call = videoClient?.call(callType, callId);
    await call?.getOrCreate({
      ring: true,
      data: {
        custom: { channelCid: channel?.cid },
        members: members,
      },
    });
  } catch (error) {
    console.log('Failed to createCall:', error);
  }
}, [videoClient, members, channel?.cid]);
```

_Note: In our application, we derive the `members` from `channel.state?.members`. Also, `joinCallHandler` can now be used on press of a button._

## Further Integration

Congratulations on completing this guide. You've learned how to build two very popular use cases - Meeting and Ringing Calls. However, our SDK supports multiple other use cases and more advanced features. If you're looking to integrate more of our supported functionality, we recommend checking out the following guides:

[//]: # '* [guide](05-advanced/02-push-notification/01-overview.mdx)'

(../02-guides/05-socket-events.mdx)

- [Call Lifecycle](../02-guides/02-call-lifecycle.mdx): It's important to understand the lifecycle of our SDK and Calls to properly build complex use cases for your users.
- [Call Engine](../02-guides/03-call-engine.mdx): If you're looking to utilize our state machine to the fullest, explore what our internal CallEngine does and how to listen to state.
- [Deep linking](../05-advanced/01-deeplinking.mdx): Deep linking is very useful for Meeting apps where you can simply send a link for the Call that lets people join.
- [Push Notifications](../05-advanced/02-push-notifications.mdx): Apps where Ring people and invite them to Calls heavily rely on push notifications. Learn how to integrate them with our SDK.

Alternatively, if you're modeling your app based on popular apps, like Messenger, Telegram, Zoom, Google Meet, Twitter Spaces or Twitch, we have several guides and template projects prepared for you:

- [Chat + Video](../02-guides/06-chat-with-video.mdx): Messenger and Telegram like applications feature Chat as a primary source of communication, with Video being secondary. To build a similar app, follow our Chat + Video guide that provides you with a template project to kick start your app, with all the UI and setup pre-baked.
- [Audio Rooms](../02-guides/07-audio-rooms.mdx): Some apps feature live audio rooms where people gather to discuss ideas and fun topics. Apps like Twitter Spaces are popular and you can build them using our Audio Rooms guide. It also prepares a template project for you that cuts the time you need to start working on your app.
- [Livestream](../02-guides/08-livestream.mdx): Last, but not least, our Livestream guide teaches you how to build an app where one person streams their tracks to a group of people in real time. By the end of the guide, you'll have a project that prepares most of the setup for you.
