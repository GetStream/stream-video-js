---
id: 06-chat-with-video
title: Chat with Video
---

## Building Chat Apps With Video Support

One of the most common chat app use cases is having a chat feature in your app that allows users to
engage in audio and video communication. This direct integration allows for simple transition between
text and images to more complex media.

Stream supports this use case, out-of-the-box.
In this guide, you'll walk through all the steps required to integrate our Chat and Video React Native SDKs into a cohesive whole.
You'll cover the following:

- Creating a Chat app.
- Adding Stream dependencies.
- Creating Stream clients.
- Authenticating Chat and Video users.
- Building custom Call attachments and "Start Call" UI.

By the end of this guide, your app will look like this:

[//]: # 'todo: add a screenshot'

You'll have the ability to create messaging conversations, in which you can start calls as a custom attachment.
Anyone in the chat will then be notified accordingly and can join the call.

Let's see how to implement this.

## Prepare your development environment on your machine

To get started with the guide, ensure you have set up your [development environment for React Native](https://reactnative.dev/docs/environment-setup).
Stream Chat supports creating applications using Expo and React Native CLI. But Stream Video currently only supports React Native CLI, so we will only focus on React Native CLI in this documentation.

## Creating the chat project

The easiest way to get a chat project up and running can be done by using the [Chat Starter Kit Template](https://github.com/GetStream/react-native-stream-chat-template#react-native-stream-chat-template) or to
follow [React Native Chat Tutorial](https://getstream.io/chat/react-native-chat/tutorial/) first and get a basic chat screens ready in your app.

## Add Stream's Video SDK and it's peer dependencies

```bash
yarn add stream-video-react-native react-native-webrtc react-native-callkeep react-native-incall-manager react-native-svg text-encoding-polyfill
```

Some dependencies require us to make changes to our application for all functionalities to be available. Please apply the following steps:

- `react-native-webrtc` installation on [Android](https://github.com/react-native-webrtc/react-native-webrtc/blob/master/Documentation/AndroidInstallation.md) and [iOS](https://github.com/react-native-webrtc/react-native-webrtc/blob/master/Documentation/iOSInstallation.md).
- `react-native-svg` be aware of [compatibility](https://github.com/software-mansion/react-native-svg#supported-react-native-versions) with RN versions and [troubleshooting](https://github.com/software-mansion/react-native-svg#troubleshooting) steps.
- `react-native-incall-manager` installation on [Android](https://github.com/react-native-webrtc/react-native-incall-manager#android) and [iOS](https://github.com/react-native-webrtc/react-native-incall-manager#ios).
- `react-native-callkeep` installation on [Android](https://github.com/react-native-webrtc/react-native-callkeep/blob/master/docs/android-installation.md) and [iOS](https://github.com/react-native-webrtc/react-native-callkeep/blob/master/docs/ios-installation.md).

So what did we install precisely?

- `stream-video-react-native` (SVRN) is Stream's Video SDK which contains UI components, hooks and utility functions that will enable audio/video calls.
- `react-native-webrtc` is a WebRTC module for React Native, SVRN depends on this dependency, it's components and utilities to render audio/video tracks and interact with the phone's media devices.
- `react-native-incall-manager` handles media-routes/sensors/events during a audio/video call.
- `react-native-callkeep` utilises CallKit (iOS) and ConnectionService (Android). SVRN's uses this dependency to render native ringers and handle accepting/declining a call when the app is in background/dead mode.
- `react-native-svg` provides SVG support to React Native, SVRN's components and it's icons are reliant on this dependency.

## First things first: encoding, polyfills and globals configuration

Add the following imports and statements to your `index.js` file in the project's root.

```tsx
/** URL polyfill */
import 'text-encoding-polyfill';
/** Text decoder polyfill */
import 'react-native-url-polyfill/auto';
/** crypto.getRandomValues polyfill for uuid */
import 'react-native-get-random-values';
import {registerGlobals} from 'react-native-webrtc';
...

// We're registering globals, because our video JS client is serving SDKs that use browser based webRTC functions.
// This will result in creation of 2 global objects: `window` and `navigator`
// Further [reading](https://github.com/react-native-webrtc/react-native-webrtc/blob/16cff1523da457dbcc27bb0744ee2bad3a987c41/Documentation/BasicUsage.md#registering-globals) about this process
if (Platform.OS !== 'web') {
  registerGlobals();
}
```

### Create `StreamVideoClient`

Firstly we need to authenticate the Video SDKâ€™s Client.
You will need a user and token to authenticate a client.
You can use the `client` from the Chat SDK to create the user object.
To do this, you can import the hook, `useChatContext`, and use the `client` from it, as in the example below.
`StreamVideoClient` expects API Key as the first arguments. It also expects `options`.

```tsx
import { useChatContext } from 'stream-chat-react-native';
import { StreamVideoClient } from '@stream-io/video-client';
import { useMemo } from 'react';

// Inside your component
const { client: chatClient } = useChatContext();

const user = useMemo<VideoProps['user']>(
  () => ({
    id: client.user?.id as string,
    name: client.user?.name as string,
    imageUrl: client.user?.image as string,
  }),
  [chatClient.user],
);

//fetch the token
const token = chatClient._getToken() || `Your Token`;

const APIParams = {
  apiKey: `Your Key`,
};

// authenticate and create the video client
const client = new StreamVideoClient(APIParams.apiKey);
```

All types used in the example above can be found in the end version of this [project](https://github.com/GetStream/stream-video-js/blob/a42a72fcde67877287f4df292524311723ea4e0f/packages/react-native-call-starter-kit/src/types.ts)

### Connecting and disconnecting from the video client

We will connect to the Stream's client instance we've created right after the component has mounted.
When the component un-mounts, we will disconnect from the client.

_Note: We will use the API key, user and the token from the previous step._

```tsx
import React, {useEffect, useState} from 'react';
import {ActivityIndicator, SafeAreaView, StyleSheet, Text} from 'react-native';
...

const App = () => {
  ...
  const [connected, setConnected] = useState(false);
  const [error, setError] = useState(undefined);

  useEffect(() => {
    const run = async () => {
      try {
        await client.connect(user, token);
        setConnected(true);
      } catch (err) {
        setError(`Failed to establish connection - ${err}`);
      }
    };
    run();
    return () => {
      client.disconnect();
    };
  }, []);

  if (!connected) {
    return (
      <SafeAreaView style={{ flex: 1 }}>
        <ActivityIndicator size={'large'} style={StyleSheet.absoluteFill} />
      </SafeAreaView>
    );
  }

  return !error ? (
    <SafeAreaView style={{ flex: 1 }}>
      <Text>We're connected now and ready to go ðŸš€</Text>
    </SafeAreaView>
  ) : (
    <Text>{error}</Text>
  );
};
```

For simplicity you can also use this hook:

```tsx title="src/hooks/useVideoClient.tsx"
import { StreamVideoClient } from '@stream-io/video-client';
import { useEffect, useState } from 'react';
import { VideoProps } from '../types';

const APIParams = {
  apiKey: STREAM_API_KEY, // see <video>/data/fixtures/apps.yaml for API key/secret
};

export const useVideoClient = ({ user, token }: VideoProps) => {
  const [videoClient, setVideoClient] = useState<StreamVideoClient>();

  useEffect(() => {
    const run = async () => {
      try {
        if (user && token) {
          const client = new StreamVideoClient(APIParams.apiKey);
          await client.connectUser(user, token);
          setVideoClient(client);
        }
      } catch (err) {
        console.error('Failed to establish connection', err);
      }
    };

    run();
  }, [token, user]);

  return { videoClient };
};
```

### Providing the video client and Call logic to the rest of the app

Our `StreamVideo` component will provide our recently created video client to the rest of the underlying components.
We will use the `client` created in the previous step and provide to the `client` prop of the `StreamVideo` component.

_Note: Make sure to wrap your entire application in `StreamVideo`._

```tsx
import React from 'react';
import {StreamMeeting, StreamCall } from '@stream-io/video-react-native-sdk';
...

const App = () => {
  ...
  return (
    <StreamVideo client={client}>
      {children}
    </StreamVideo>
  );
};

```

### Adding call cycle handlers

`StreamVideo` component has a `callCycleHandlers` prop of type object that expects:

- `onActiveCall` handler to deal with the case when the call is active.
- `onHangupCall` handler to deal with the case when the call is hung up.
- `onIncomingCall` handler to deal with the case when there's an incoming call.
- `onOutgoingCall` handler to deal with the case when there's an outgoing call.
- `onRejectCall` handler to deal with the case when an incoming call is rejected.

These handlers can be used to navigate to particular screens depending on the state.

An example can be seen below:

```tsx title="App.tsx"
import React from 'react';
import {ActivityIndicator, StyleSheet} from 'react-native';
import {StreamMeeting, StreamCall } from '@stream-io/video-react-native-sdk';
...

const App = () => {
  ...

  return (
    <StreamVideo
      client={videoClient}
      callCycleHandlers={{
        onActiveCall: () => console.log("Moving to active call screen"),
        onIncomingCall: () => console.log("Incoming call created"),
        onOutgoingCall: () => console.log("Outgoing call created"),
        onHangupCall: () => console.log("Call Hanged up"),
        onRejectCall: () => console.log("Incoming call rejected"),
      }}>
      {children}
    </StreamVideo>
  );
};
```

_Note: In our example, we navigate to particular screens where we render the `IncomingCallView`, `OutgoingCallView` and `ActiveCall` components. This is done using the package [react-navigation](http://reactnavigation.org/)._

### Creating the call

To create/start a call, you can use the `getOrCreateCall` function provided by the video client.
This function expects `callId`, `type` and `input` as arguments for the call to work.
The `input` field expects the `ring` as `true` and the `members` to whom we want to call.
An example of the usage is shared below:

```tsx
import React, {useCallback} from 'react';
import {useStreamVideoClient} from '@stream-io/video-react-native-sdk';
...

export default () => {
	const videoClient = useStreamVideoClient();

	const joinCallHandler = useCallback(() => {
	  if (videoClient) {
	    try {
	      videoClient?.call("default", callID).getOrCreate({
	          ring: true,
	          members: members.map((memberId) => {
	            return {
	              user_id: memberId,
	            };
	          }),
	        });
	    } catch (error) {
	      console.log('Failed to createCall', callID, 'default', error);
	    }
	  }
	}, [videoClient, members]);
}
```

_Note: In our application, we derive the `members` from `channel.state?.members`._

### Rendering the Active call view

To render the active call view, you can import `ActiveCall` component from the React Native Video SDK.
Use it in the Screen/View where you want to render it.
This component expects a handlers to deal with the case when user clicks on the Participants View icon(`onOpenCallParticipantsInfoView`).

```tsx
import React from 'react';
import { ActiveCall, useActiveCall } from '@stream-io/video-react-native-sdk';
import { ActivityIndicator, StyleSheet } from 'react-native';

export const ActiveCallScreen = ({ navigation }: Props) => {
  const activeCall = useActiveCall();

  // Handler executed when the call participants icon is clicked. This is used to render CallParticipantsInfoView.
  const onOpenCallParticipantsInfoViewHandler = () => {
    console.log('Call Participants Info View');
  };

  // Since the call takes time to join we show an activityindicator until then.
  if (!activeCall) {
    return <ActivityIndicator size={'large'} style={StyleSheet.absoluteFill} />;
  }

  return (
    <ActiveCall
      onOpenCallParticipantsInfoView={onOpenCallParticipantsInfoViewHandler}
    />
  );
};
```

### Rendering the Incoming call view

To render the incoming call view, you can import `IncomingCallView` from the React Native Video SDK and use it in the Screen/View of your choice.

_Note: In our [react-native-call-starter-kit](https://github.com/GetStream/stream-video-js/blob/a42a72fcde67877287f4df292524311723ea4e0f/packages/react-native-call-starter-kit/), we use the handlers to navigate among screens._

```tsx
import React from 'react';
import { IncomingCallView } from '@stream-io/video-react-native-sdk';

const IncomingCallScreen = () => {
  return <IncomingCallView />;
};

export default IncomingCallScreen;
```

### Rendering the Outgoing call view

To render the outgoing call view, you can import `OutgoingCallView` from the React Native Video SDK and use it in the Screen/View of your choice.

```tsx
import React from 'react';
import { OutgoingCallView } from '@stream-io/video-react-native-sdk';

const OutgoingCallScreen = () => {
  return <OutgoingCallView />;
};

export default OutgoingCallScreen;
```

### Rendering the CallParticipantsInfoView component

To render the call participants info view, you can import `CallParticipantsInfoView` from the Video SDK and use it in the Screen/View where you want to render it.

```tsx
import React from 'react';
import { CallParticipantsInfoView } from '@stream-io/video-react-native-sdk';

export function CallParticipansInfoScreen() {
  return <CallParticipantsInfoView />;
}
```
