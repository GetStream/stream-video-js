---
id: 06-chat-with-video
title: Chat with Video
---

## Building Chat Apps With Video Support

One of the most common chat app use cases is having a chat feature in your app that allows users to
engage in audio and video communication. This direct integration allows for simple transition between
text and images to more complex media.

Stream supports this use case, out-of-the-box.
In this guide, you'll walk through all the steps required to integrate our Chat and Video React Native SDKs into a cohesive whole.
You'll cover the following:

- Creating a Chat app.
- Adding Stream dependencies.
- Creating Stream clients.
- Authenticating Chat and Video users.
- Building custom Call attachments and "Start Call" UI.

By the end of this guide, your app will look like this:

[//]: # 'todo: add a screenshot'

You'll have the ability to create messaging conversations, in which you can start calls as a custom attachment.
Anyone in the chat will then be notified accordingly and can join the call.

Let's see how to implement this.

## Prepare your development environment on your machine

To get started with the guide, ensure you have set up your [development environment for React Native](https://reactnative.dev/docs/environment-setup).
Stream Chat supports creating applications using Expo and React Native CLI. But Stream Video currently only supports React Native CLI, so we will only focus on React Native CLI in this documentation.

## Creating the chat project

The easiest way to get a chat project up and running can be done by using the [Chat Starter Kit Template](https://github.com/GetStream/react-native-stream-chat-template#react-native-stream-chat-template) or to
follow [React Native Chat Tutorial](https://getstream.io/chat/react-native-chat/tutorial/) first and get a basic chat screens ready in your app.

## Install dependencies and initial setup

Follow this [guide](01-basics/03-installation.mdx) to install the dependencies and setup the project.

### Create `StreamVideoClient`

Firstly we need to authenticate the Video SDKâ€™s Client.
You will need a user and token to authenticate a client.
You can use the `client` from the Chat SDK to create the user object.
To do this, you can import the hook, `useChatContext`, and use the `client` from it, as in the example below.
`StreamVideoClient` expects API Key as the first arguments. It also expects `options`.

```tsx
import { useChatContext } from 'stream-chat-react-native';
import { StreamVideoClient } from '@stream-io/video-client';
import { useMemo } from 'react';

// Inside your component
const { client: chatClient } = useChatContext();

const user = useMemo<VideoProps['user']>(
  () => ({
    id: client.user?.id as string,
    name: client.user?.name as string,
    imageUrl: client.user?.image as string,
  }),
  [chatClient.user],
);

//fetch the token
const token = chatClient._getToken() || `Your Token`;

const APIParams = {
  apiKey: `Your Key`,
};

// authenticate and create the video client
const client = new StreamVideoClient(APIParams.apiKey);
```

All types used in the example above can be found in the end version of this [project](https://github.com/GetStream/stream-video-js/blob/a42a72fcde67877287f4df292524311723ea4e0f/packages/react-native-call-starter-kit/src/types.ts)

### Connecting and disconnecting from the video client

We will connect to the Stream's client instance we've created right after the component has mounted.
When the component un-mounts, we will disconnect from the client.

_Note: We will use the API key, user and the token from the previous step._

```tsx
import React, {useEffect, useState} from 'react';
import {ActivityIndicator, SafeAreaView, StyleSheet, Text} from 'react-native';
...

const App = () => {
  ...
  const [connected, setConnected] = useState(false);
  const [error, setError] = useState(undefined);

  useEffect(() => {
    const run = async () => {
      try {
        await client.connect(user, token);
        setConnected(true);
      } catch (err) {
        setError(`Failed to establish connection - ${err}`);
      }
    };
    run();
    return () => {
      client.disconnect();
    };
  }, []);

  if (!connected) {
    return (
      <SafeAreaView style={{ flex: 1 }}>
        <ActivityIndicator size={'large'} style={StyleSheet.absoluteFill} />
      </SafeAreaView>
    );
  }

  return !error ? (
    <SafeAreaView style={{ flex: 1 }}>
      <Text>We're connected now and ready to go ðŸš€</Text>
    </SafeAreaView>
  ) : (
    <Text>{error}</Text>
  );
};
```

For simplicity, you can also use the `useCreateStreamVideoClient` [hook](../../call-engine/hooks#usecreatestreamvideoclient) to connect and disconnect from the client.

### Providing the video client and Call logic to the rest of the app

Our `StreamVideoCall` component will provide our recently created video client to the rest of the underlying components.
The `client` created above can be used as follows and needs to be provided to the `client` prop of the `StreamVideoCall` component.

_Note: Make sure to wrap your entire application in `StreamVideoCall`._

```tsx
import React, {useState} from 'react';
import {StreamVideoCall} from '@stream-io/video-react-native-sdk';
...

const App = () => {
  const [callId, SetCallId] = useState<string>(uuidv4().toLowerCase());
    const videoClient = useCreateStreamVideoClient({
    user,
    tokenOrProvider: token,
    apiKey: APIParams.apiKey,
  });

  ...
  return (
    <StreamVideoCall
      callId={callId}
      client={client}
    >
      {children}
    </StreamVideoCall>
  );
};

```

### Adding call cycle handlers

`StreamVideoCall` component has also a `callCycleHandlers` prop of type object that expects:

- `onCallJoined` callback that is called after the user joins the call.
- `onCallHungUp` callback that is called after the user hangs up the call.
- `onCallIncoming` callback that is called when a callee receives an incoming call.
- `onCallOutgoing` callback that is called after a caller creates an outgoing call.
- `onCallRejected` callback that is called after a callee rejects an incoming call.

These handlers can be used for preparing/tearing down or for navigation to particular screens depending on the call state.

An example can be seen below:

```tsx title="App.tsx"
import React from 'react';
import {ActivityIndicator, StyleSheet} from 'react-native';
import {StreamVideoCall } from '@stream-io/video-react-native-sdk';
...

const App = () => {
  ...

  return (
    <StreamVideoCall
      callId={callId}
      client={videoClient}
      callCycleHandlers={{
        onCallJoined: () => console.log("Moving to active call screen"),
        onCallIncoming: () => console.log("Incoming call created"),
        onCallOutgoing: () => console.log("Outgoing call created"),
        onCallHungUp: () => console.log("Call hung up"),
        onCallRejected: () => console.log("Incoming call rejected"),
      }}>
      {children}
    </StreamVideoCall>
  );
};
```

_Note: In our example, we navigate to particular screens where we render the `IncomingCallView`, `OutgoingCallView` and `ActiveCall` components.
This is done using the package [react-navigation](http://reactnavigation.org/)._

### Creating the call

StreamVideoCall already created a call instance based on the provided `callId`.
We retrieve this call instance using the `useCall` hook.
To start a ring call we use the `getOrCreateCall` function from the call instance.
This function expects a `members` to whom we want to call and a `ring` `boolean` to indicate that we want to have a ring call.

An example of the usage is shared below:

```tsx
import React, {useCallback} from 'react';
import {useAppContext} from '../context/AppContext';
import {useCall} from '@stream-io/video-react-native-sdk';
import {useChatContext} from 'stream-chat-react-native';
...

export default () => {
  const {channel} = useAppContext();
  const {client} = useChatContext();
  const call = useCall();
  const members = Object.keys(channel?.state?.members || {}).filter(
    member => member !== client.user?.id,
  );
  const joinCallHandler = useCallback(async () => {
    if (!call) {
      return;
    }

    try {
      await call.getOrCreate({
        ring: true,
        data: {
          members: members.map(ringingUserId => {
            return {
              user_id: ringingUserId,
            };
          }),
        },
      });
    } catch (error) {
      console.log('Failed to createCall', call.id, 'default', error);
    }
  }, [call, members]);
}
```

_Note: In our application, we derive the `members` from `channel.state?.members`._

### Rendering the Active call view

To render the active call view, you can import `ActiveCall` component from the React Native Video SDK.
Use it in the Screen/View where you want to render it.
To handle the case of what should happen when user clicks on the Participants View icon, you can pass your custom handlers to `StreamVideoRN.setConfig` as in the example below.

```tsx
import React, { useCallback } from 'react';
import {
  ActiveCall,
  useCall,
  StreamVideoRN,
} from '@stream-io/video-react-native-sdk';
import { ActivityIndicator, SafeAreaView, StyleSheet } from 'react-native';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { NavigationStackParamsList } from '../types';
import { theme } from '@stream-io/video-react-native-sdk/src/theme';

type Props = NativeStackScreenProps<
  NavigationStackParamsList,
  'ActiveCallScreen'
>;

export function ActiveCallScreen({ navigation }: Props) {
  const activeCall = useCall();

  // Handler executed when the call participants icon is clicked. This is used to render CallParticipantsInfoView.
  const onOpenCallParticipantsInfoViewHandler = useCallback(() => {
    navigation.navigate('CallParticipantsInfoScreen');
  }, [navigation]);

  StreamVideoRN.setConfig({
    onOpenCallParticipantsInfoView: onOpenCallParticipantsInfoViewHandler,
  });

  // Since joining the call might take some time, we render an ActivityIndicator.
  if (!activeCall) {
    return <ActivityIndicator size={'large'} style={StyleSheet.absoluteFill} />;
  }
  return (
    <SafeAreaView style={styles.wrapper}>
      <ActiveCall />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  wrapper: {
    flex: 1,
    backgroundColor: theme.light.static_grey,
  },
});
```

### Rendering the Incoming call view

To render the incoming call view, you can import `IncomingCallView` from the React Native Video SDK and use it in the
Screen/View of your choice.

_Note: In our [react-native-call-starter-kit](https://github.com/GetStream/stream-video-js/blob/a42a72fcde67877287f4df292524311723ea4e0f/packages/react-native-call-starter-kit/), we use the handlers to navigate among screens._

```tsx
import React from 'react';
import { IncomingCallView } from '@stream-io/video-react-native-sdk';

const IncomingCallScreen = () => {
  return <IncomingCallView />;
};

export default IncomingCallScreen;
```

### Rendering the Outgoing call view

To render the outgoing call view, you can import `OutgoingCallView` from the React Native Video SDK and use it in the Screen/View of your choice.

```tsx
import React from 'react';
import { OutgoingCallView } from '@stream-io/video-react-native-sdk';

const OutgoingCallScreen = () => {
  return <OutgoingCallView />;
};

export default OutgoingCallScreen;
```

### Rendering the CallParticipantsInfoView component

To render the call participants info view, you can import `CallParticipantsInfoView` from the Video SDK and use it in the Screen/View where you want to render it.

```tsx
import React from 'react';
import { CallParticipantsInfoView } from '@stream-io/video-react-native-sdk';

export function CallParticipansInfoScreen() {
  return <CallParticipantsInfoView />;
}
```

## Further Integration

Congratulations on completing this guide. You've learned how to build two very popular use cases - Meeting and Ringing Calls. However, our SDK supports multiple other use cases and more advanced features. If you're looking to integrate more of our supported functionality, we recommend checking out the following guides:

[//]: # '* [guide](05-advanced/02-push-notification/01-overview.mdx)'

(../02-guides/04-socket-events.mdx)

- [Call Lifecycle](../02-guides/02-call-lifecycle.mdx): It's important to understand the lifecycle of our SDK and Calls to properly build complex use cases for your users.
- [Call Engine](../02-guides/03-call-engine.mdx): If you're looking to utilize our state machine to the fullest, explore what our internal CallEngine does and how to listen to state.
- [Deep linking](../05-advanced/01-deeplinking.mdx): Deep linking is very useful for Meeting apps where you can simply send a link for the Call that lets people join.
- [Push Notifications](../05-advanced/02-push-notifications.mdx): Apps where Ring people and invite them to Calls heavily rely on push notifications. Learn how to integrate them with our SDK.

Alternatively, if you're modeling your app based on popular apps, like Messenger, Telegram, Zoom, Google Meet, Twitter Spaces or Twitch, we have several guides and template projects prepared for you:

- [Chat + Video](../02-guides/06-chat-with-video.mdx): Messenger and Telegram like applications feature Chat as a primary source of communication, with Video being secondary. To build a similar app, follow our Chat + Video guide that provides you with a template project to kick start your app, with all the UI and setup pre-baked.
- [Audio Rooms](../02-guides/07-audio-rooms.mdx): Some apps feature live audio rooms where people gather to discuss ideas and fun topics. Apps like Twitter Spaces are popular and you can build them using our Audio Rooms guide. It also prepares a template project for you that cuts the time you need to start working on your app.
- [Livestream](../02-guides/08-livestream.mdx): Last, but not least, our Livestream guide teaches you how to build an app where one person streams their tracks to a group of people in real time. By the end of the guide, you'll have a project that prepares most of the setup for you.
