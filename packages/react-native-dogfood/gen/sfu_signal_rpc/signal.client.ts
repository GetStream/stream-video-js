/* eslint-disable */
// @generated by protobuf-ts 2.8.0 with parameter long_type_string,generate_dependencies,client_generic,server_none,eslint_disable
// @generated from protobuf file "sfu_signal_rpc/signal.proto" (package "stream.video.sfu", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { SignalServer } from "./signal";
import type { UpdateVideoQualityResponse } from "./signal";
import type { UpdateVideoQualityRequest } from "./signal";
import type { UpdateMuteStateResponse } from "./signal";
import type { UpdateMuteStateRequest } from "./signal";
import type { UpdateSubscriptionsResponse } from "./signal";
import type { UpdateSubscriptionsRequest } from "./signal";
import type { IceCandidateResponse } from "./signal";
import type { IceCandidateRequest } from "./signal";
import type { SendAnswerResponse } from "./signal";
import type { SendAnswerRequest } from "./signal";
import type { SetPublisherResponse } from "./signal";
import type { SetPublisherRequest } from "./signal";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { JoinResponse } from "./signal";
import type { JoinRequest } from "./signal";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service stream.video.sfu.SignalServer
 */
export interface ISignalServerClient {
    /**
     * Join sets up the peer connection that is used to subscribe to A/V and the data channel for signaling
     * in WebRTC terms, this contains the SDP offer for the user peer connection
     *
     * @generated from protobuf rpc: Join(stream.video.sfu.JoinRequest) returns (stream.video.sfu.JoinResponse);
     */
    join(input: JoinRequest, options?: RpcOptions): UnaryCall<JoinRequest, JoinResponse>;
    /**
     * SetPublisher sends the WebRTC offer for the peer connection used to publish A/V
     *
     * @generated from protobuf rpc: SetPublisher(stream.video.sfu.SetPublisherRequest) returns (stream.video.sfu.SetPublisherResponse);
     */
    setPublisher(input: SetPublisherRequest, options?: RpcOptions): UnaryCall<SetPublisherRequest, SetPublisherResponse>;
    /**
     * @generated from protobuf rpc: SendAnswer(stream.video.sfu.SendAnswerRequest) returns (stream.video.sfu.SendAnswerResponse);
     */
    sendAnswer(input: SendAnswerRequest, options?: RpcOptions): UnaryCall<SendAnswerRequest, SendAnswerResponse>;
    /**
     * @generated from protobuf rpc: SendIceCandidate(stream.video.sfu.IceCandidateRequest) returns (stream.video.sfu.IceCandidateResponse);
     */
    sendIceCandidate(input: IceCandidateRequest, options?: RpcOptions): UnaryCall<IceCandidateRequest, IceCandidateResponse>;
    /**
     * UpdateSubscribers is used to notify the SFU about the list of video subscriptions
     * TODO: sync subscriptions based on this + update tracks using the dimension info sent by the user
     *
     * @generated from protobuf rpc: UpdateSubscriptions(stream.video.sfu.UpdateSubscriptionsRequest) returns (stream.video.sfu.UpdateSubscriptionsResponse);
     */
    updateSubscriptions(input: UpdateSubscriptionsRequest, options?: RpcOptions): UnaryCall<UpdateSubscriptionsRequest, UpdateSubscriptionsResponse>;
    /**
     * @generated from protobuf rpc: UpdateMuteState(stream.video.sfu.UpdateMuteStateRequest) returns (stream.video.sfu.UpdateMuteStateResponse);
     */
    updateMuteState(input: UpdateMuteStateRequest, options?: RpcOptions): UnaryCall<UpdateMuteStateRequest, UpdateMuteStateResponse>;
    /**
     * @generated from protobuf rpc: RequestVideoQuality(stream.video.sfu.UpdateVideoQualityRequest) returns (stream.video.sfu.UpdateVideoQualityResponse);
     */
    requestVideoQuality(input: UpdateVideoQualityRequest, options?: RpcOptions): UnaryCall<UpdateVideoQualityRequest, UpdateVideoQualityResponse>;
}
/**
 * @generated from protobuf service stream.video.sfu.SignalServer
 */
export class SignalServerClient implements ISignalServerClient, ServiceInfo {
    typeName = SignalServer.typeName;
    methods = SignalServer.methods;
    options = SignalServer.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Join sets up the peer connection that is used to subscribe to A/V and the data channel for signaling
     * in WebRTC terms, this contains the SDP offer for the user peer connection
     *
     * @generated from protobuf rpc: Join(stream.video.sfu.JoinRequest) returns (stream.video.sfu.JoinResponse);
     */
    join(input: JoinRequest, options?: RpcOptions): UnaryCall<JoinRequest, JoinResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<JoinRequest, JoinResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SetPublisher sends the WebRTC offer for the peer connection used to publish A/V
     *
     * @generated from protobuf rpc: SetPublisher(stream.video.sfu.SetPublisherRequest) returns (stream.video.sfu.SetPublisherResponse);
     */
    setPublisher(input: SetPublisherRequest, options?: RpcOptions): UnaryCall<SetPublisherRequest, SetPublisherResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetPublisherRequest, SetPublisherResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: SendAnswer(stream.video.sfu.SendAnswerRequest) returns (stream.video.sfu.SendAnswerResponse);
     */
    sendAnswer(input: SendAnswerRequest, options?: RpcOptions): UnaryCall<SendAnswerRequest, SendAnswerResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<SendAnswerRequest, SendAnswerResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: SendIceCandidate(stream.video.sfu.IceCandidateRequest) returns (stream.video.sfu.IceCandidateResponse);
     */
    sendIceCandidate(input: IceCandidateRequest, options?: RpcOptions): UnaryCall<IceCandidateRequest, IceCandidateResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<IceCandidateRequest, IceCandidateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateSubscribers is used to notify the SFU about the list of video subscriptions
     * TODO: sync subscriptions based on this + update tracks using the dimension info sent by the user
     *
     * @generated from protobuf rpc: UpdateSubscriptions(stream.video.sfu.UpdateSubscriptionsRequest) returns (stream.video.sfu.UpdateSubscriptionsResponse);
     */
    updateSubscriptions(input: UpdateSubscriptionsRequest, options?: RpcOptions): UnaryCall<UpdateSubscriptionsRequest, UpdateSubscriptionsResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateSubscriptionsRequest, UpdateSubscriptionsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: UpdateMuteState(stream.video.sfu.UpdateMuteStateRequest) returns (stream.video.sfu.UpdateMuteStateResponse);
     */
    updateMuteState(input: UpdateMuteStateRequest, options?: RpcOptions): UnaryCall<UpdateMuteStateRequest, UpdateMuteStateResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateMuteStateRequest, UpdateMuteStateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: RequestVideoQuality(stream.video.sfu.UpdateVideoQualityRequest) returns (stream.video.sfu.UpdateVideoQualityResponse);
     */
    requestVideoQuality(input: UpdateVideoQualityRequest, options?: RpcOptions): UnaryCall<UpdateVideoQualityRequest, UpdateVideoQualityResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateVideoQualityRequest, UpdateVideoQualityResponse>("unary", this._transport, method, opt, input);
    }
}
