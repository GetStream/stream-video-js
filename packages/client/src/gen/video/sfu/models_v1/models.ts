/* eslint-disable */
// @generated by protobuf-ts 2.8.1 with parameter long_type_string,client_generic,server_none,eslint_disable
// @generated from protobuf file "video/sfu/models_v1/models.proto" (package "stream.video.sfu.models_v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../google/protobuf/timestamp";
/**
 * @generated from protobuf message stream.video.sfu.models_v1.CallState
 */
export interface CallState {
    /**
     * @generated from protobuf field: repeated stream.video.sfu.models_v1.Participant participants = 1;
     */
    participants: Participant[];
}
/**
 * @generated from protobuf message stream.video.sfu.models_v1.Call
 */
export interface Call {
    /**
     * Unique call ID as identified by Coordinator
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * A timestamp of the call start. The timestamp is set when first participant connects
     *
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 2;
     */
    createdAt?: Timestamp;
}
/**
 * those who are online in the call
 *
 * @generated from protobuf message stream.video.sfu.models_v1.Participant
 */
export interface Participant {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string session_id = 2;
     */
    sessionId: string;
    /**
     * @generated from protobuf field: bool video = 3;
     */
    video: boolean;
    /**
     * @generated from protobuf field: bool audio = 4;
     */
    audio: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp connected_at = 5;
     */
    connectedAt?: Timestamp;
}
/**
 * @generated from protobuf message stream.video.sfu.models_v1.StreamQuality
 */
export interface StreamQuality {
    /**
     * @generated from protobuf field: stream.video.sfu.models_v1.VideoQuality video_quality = 1;
     */
    videoQuality: VideoQuality;
    /**
     * @generated from protobuf field: string user_id = 2;
     */
    userId: string;
}
/**
 * @generated from protobuf message stream.video.sfu.models_v1.VideoDimension
 */
export interface VideoDimension {
    /**
     * @generated from protobuf field: uint32 width = 1;
     */
    width: number;
    /**
     * @generated from protobuf field: uint32 height = 2;
     */
    height: number;
}
/**
 * @generated from protobuf message stream.video.sfu.models_v1.VideoLayer
 */
export interface VideoLayer {
    /**
     * for tracks with a single layer, this should be HIGH
     *
     * @generated from protobuf field: string rid = 1;
     */
    rid: string;
    /**
     * @generated from protobuf field: stream.video.sfu.models_v1.VideoDimension video_dimension = 2;
     */
    videoDimension?: VideoDimension;
    /**
     * target bitrate, server will measure actual
     *
     * @generated from protobuf field: uint32 bitrate = 4;
     */
    bitrate: number;
}
/**
 * @generated from protobuf message stream.video.sfu.models_v1.SimulcastCodecInfo
 */
export interface SimulcastCodecInfo {
    /**
     * @generated from protobuf field: string mime_type = 1;
     */
    mimeType: string;
    /**
     * @generated from protobuf field: string mid = 2;
     */
    mid: string;
    /**
     * @generated from protobuf field: string cid = 3;
     */
    cid: string;
    /**
     * @generated from protobuf field: repeated stream.video.sfu.models_v1.VideoLayer layers = 4;
     */
    layers: VideoLayer[];
}
/**
 * @generated from protobuf message stream.video.sfu.models_v1.Codec
 */
export interface Codec {
    /**
     * @generated from protobuf field: string mime = 1;
     */
    mime: string;
    /**
     * @generated from protobuf field: string fmtp_line = 2;
     */
    fmtpLine: string;
    /**
     * @generated from protobuf field: uint32 clock_rate = 3;
     */
    clockRate: number;
    /**
     * @generated from protobuf field: bool hw_accelerated = 4;
     */
    hwAccelerated: boolean;
}
/**
 * @generated from protobuf message stream.video.sfu.models_v1.AudioCodecs
 */
export interface AudioCodecs {
    /**
     * @generated from protobuf field: repeated stream.video.sfu.models_v1.Codec encodes = 1;
     */
    encodes: Codec[];
    /**
     * @generated from protobuf field: repeated stream.video.sfu.models_v1.Codec decodes = 2;
     */
    decodes: Codec[];
}
/**
 * @generated from protobuf message stream.video.sfu.models_v1.VideoCodecs
 */
export interface VideoCodecs {
    /**
     * @generated from protobuf field: repeated stream.video.sfu.models_v1.Codec encodes = 1;
     */
    encodes: Codec[];
    /**
     * @generated from protobuf field: repeated stream.video.sfu.models_v1.Codec decodes = 2;
     */
    decodes: Codec[];
}
/**
 * @generated from protobuf message stream.video.sfu.models_v1.CodecSettings
 */
export interface CodecSettings {
    /**
     * @generated from protobuf field: stream.video.sfu.models_v1.AudioCodecs audio = 1;
     */
    audio?: AudioCodecs;
    /**
     * @generated from protobuf field: stream.video.sfu.models_v1.VideoCodecs video = 2;
     */
    video?: VideoCodecs;
    /**
     * @generated from protobuf field: repeated stream.video.sfu.models_v1.VideoLayer layers = 3;
     */
    layers: VideoLayer[];
}
/**
 * @generated from protobuf enum stream.video.sfu.models_v1.PeerType
 */
export enum PeerType {
    /**
     * @generated from protobuf enum value: PEER_TYPE_PUBLISHER_UNSPECIFIED = 0;
     */
    PUBLISHER_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PEER_TYPE_SUBSCRIBER = 1;
     */
    SUBSCRIBER = 1
}
/**
 * @generated from protobuf enum stream.video.sfu.models_v1.ConnectionQuality
 */
export enum ConnectionQuality {
    /**
     * @generated from protobuf enum value: CONNECTION_QUALITY_BAD_UNSPECIFIED = 0;
     */
    BAD_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: CONNECTION_QUALITY_POOR = 1;
     */
    POOR = 1,
    /**
     * @generated from protobuf enum value: CONNECTION_QUALITY_GOOD = 2;
     */
    GOOD = 2
}
/**
 * @generated from protobuf enum stream.video.sfu.models_v1.VideoQuality
 */
export enum VideoQuality {
    /**
     * @generated from protobuf enum value: VIDEO_QUALITY_LOW_UNSPECIFIED = 0;
     */
    LOW_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: VIDEO_QUALITY_MID = 1;
     */
    MID = 1,
    /**
     * @generated from protobuf enum value: VIDEO_QUALITY_HIGH = 2;
     */
    HIGH = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class CallState$Type extends MessageType<CallState> {
    constructor() {
        super("stream.video.sfu.models_v1.CallState", [
            { no: 1, name: "participants", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Participant }
        ]);
    }
    create(value?: PartialMessage<CallState>): CallState {
        const message = { participants: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CallState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CallState): CallState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated stream.video.sfu.models_v1.Participant participants */ 1:
                    message.participants.push(Participant.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CallState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated stream.video.sfu.models_v1.Participant participants = 1; */
        for (let i = 0; i < message.participants.length; i++)
            Participant.internalBinaryWrite(message.participants[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.sfu.models_v1.CallState
 */
export const CallState = new CallState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Call$Type extends MessageType<Call> {
    constructor() {
        super("stream.video.sfu.models_v1.Call", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Call>): Call {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Call>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Call): Call {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at */ 2:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Call, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* google.protobuf.Timestamp created_at = 2; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.sfu.models_v1.Call
 */
export const Call = new Call$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Participant$Type extends MessageType<Participant> {
    constructor() {
        super("stream.video.sfu.models_v1.Participant", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "video", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "audio", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "connected_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Participant>): Participant {
        const message = { userId: "", sessionId: "", video: false, audio: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Participant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Participant): Participant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string session_id */ 2:
                    message.sessionId = reader.string();
                    break;
                case /* bool video */ 3:
                    message.video = reader.bool();
                    break;
                case /* bool audio */ 4:
                    message.audio = reader.bool();
                    break;
                case /* google.protobuf.Timestamp connected_at */ 5:
                    message.connectedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.connectedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Participant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string session_id = 2; */
        if (message.sessionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionId);
        /* bool video = 3; */
        if (message.video !== false)
            writer.tag(3, WireType.Varint).bool(message.video);
        /* bool audio = 4; */
        if (message.audio !== false)
            writer.tag(4, WireType.Varint).bool(message.audio);
        /* google.protobuf.Timestamp connected_at = 5; */
        if (message.connectedAt)
            Timestamp.internalBinaryWrite(message.connectedAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.sfu.models_v1.Participant
 */
export const Participant = new Participant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamQuality$Type extends MessageType<StreamQuality> {
    constructor() {
        super("stream.video.sfu.models_v1.StreamQuality", [
            { no: 1, name: "video_quality", kind: "enum", T: () => ["stream.video.sfu.models_v1.VideoQuality", VideoQuality, "VIDEO_QUALITY_"] },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamQuality>): StreamQuality {
        const message = { videoQuality: 0, userId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StreamQuality>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamQuality): StreamQuality {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.video.sfu.models_v1.VideoQuality video_quality */ 1:
                    message.videoQuality = reader.int32();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamQuality, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.video.sfu.models_v1.VideoQuality video_quality = 1; */
        if (message.videoQuality !== 0)
            writer.tag(1, WireType.Varint).int32(message.videoQuality);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.sfu.models_v1.StreamQuality
 */
export const StreamQuality = new StreamQuality$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VideoDimension$Type extends MessageType<VideoDimension> {
    constructor() {
        super("stream.video.sfu.models_v1.VideoDimension", [
            { no: 1, name: "width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<VideoDimension>): VideoDimension {
        const message = { width: 0, height: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VideoDimension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VideoDimension): VideoDimension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 width */ 1:
                    message.width = reader.uint32();
                    break;
                case /* uint32 height */ 2:
                    message.height = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VideoDimension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 width = 1; */
        if (message.width !== 0)
            writer.tag(1, WireType.Varint).uint32(message.width);
        /* uint32 height = 2; */
        if (message.height !== 0)
            writer.tag(2, WireType.Varint).uint32(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.sfu.models_v1.VideoDimension
 */
export const VideoDimension = new VideoDimension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VideoLayer$Type extends MessageType<VideoLayer> {
    constructor() {
        super("stream.video.sfu.models_v1.VideoLayer", [
            { no: 1, name: "rid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "video_dimension", kind: "message", T: () => VideoDimension },
            { no: 4, name: "bitrate", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<VideoLayer>): VideoLayer {
        const message = { rid: "", bitrate: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VideoLayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VideoLayer): VideoLayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string rid */ 1:
                    message.rid = reader.string();
                    break;
                case /* stream.video.sfu.models_v1.VideoDimension video_dimension */ 2:
                    message.videoDimension = VideoDimension.internalBinaryRead(reader, reader.uint32(), options, message.videoDimension);
                    break;
                case /* uint32 bitrate */ 4:
                    message.bitrate = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VideoLayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string rid = 1; */
        if (message.rid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rid);
        /* stream.video.sfu.models_v1.VideoDimension video_dimension = 2; */
        if (message.videoDimension)
            VideoDimension.internalBinaryWrite(message.videoDimension, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 bitrate = 4; */
        if (message.bitrate !== 0)
            writer.tag(4, WireType.Varint).uint32(message.bitrate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.sfu.models_v1.VideoLayer
 */
export const VideoLayer = new VideoLayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimulcastCodecInfo$Type extends MessageType<SimulcastCodecInfo> {
    constructor() {
        super("stream.video.sfu.models_v1.SimulcastCodecInfo", [
            { no: 1, name: "mime_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "mid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "layers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VideoLayer }
        ]);
    }
    create(value?: PartialMessage<SimulcastCodecInfo>): SimulcastCodecInfo {
        const message = { mimeType: "", mid: "", cid: "", layers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SimulcastCodecInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimulcastCodecInfo): SimulcastCodecInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mime_type */ 1:
                    message.mimeType = reader.string();
                    break;
                case /* string mid */ 2:
                    message.mid = reader.string();
                    break;
                case /* string cid */ 3:
                    message.cid = reader.string();
                    break;
                case /* repeated stream.video.sfu.models_v1.VideoLayer layers */ 4:
                    message.layers.push(VideoLayer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimulcastCodecInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mime_type = 1; */
        if (message.mimeType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mimeType);
        /* string mid = 2; */
        if (message.mid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mid);
        /* string cid = 3; */
        if (message.cid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cid);
        /* repeated stream.video.sfu.models_v1.VideoLayer layers = 4; */
        for (let i = 0; i < message.layers.length; i++)
            VideoLayer.internalBinaryWrite(message.layers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.sfu.models_v1.SimulcastCodecInfo
 */
export const SimulcastCodecInfo = new SimulcastCodecInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Codec$Type extends MessageType<Codec> {
    constructor() {
        super("stream.video.sfu.models_v1.Codec", [
            { no: 1, name: "mime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fmtp_line", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "clock_rate", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hw_accelerated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Codec>): Codec {
        const message = { mime: "", fmtpLine: "", clockRate: 0, hwAccelerated: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Codec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Codec): Codec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mime */ 1:
                    message.mime = reader.string();
                    break;
                case /* string fmtp_line */ 2:
                    message.fmtpLine = reader.string();
                    break;
                case /* uint32 clock_rate */ 3:
                    message.clockRate = reader.uint32();
                    break;
                case /* bool hw_accelerated */ 4:
                    message.hwAccelerated = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Codec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mime = 1; */
        if (message.mime !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mime);
        /* string fmtp_line = 2; */
        if (message.fmtpLine !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fmtpLine);
        /* uint32 clock_rate = 3; */
        if (message.clockRate !== 0)
            writer.tag(3, WireType.Varint).uint32(message.clockRate);
        /* bool hw_accelerated = 4; */
        if (message.hwAccelerated !== false)
            writer.tag(4, WireType.Varint).bool(message.hwAccelerated);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.sfu.models_v1.Codec
 */
export const Codec = new Codec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AudioCodecs$Type extends MessageType<AudioCodecs> {
    constructor() {
        super("stream.video.sfu.models_v1.AudioCodecs", [
            { no: 1, name: "encodes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Codec },
            { no: 2, name: "decodes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Codec }
        ]);
    }
    create(value?: PartialMessage<AudioCodecs>): AudioCodecs {
        const message = { encodes: [], decodes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AudioCodecs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudioCodecs): AudioCodecs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated stream.video.sfu.models_v1.Codec encodes */ 1:
                    message.encodes.push(Codec.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated stream.video.sfu.models_v1.Codec decodes */ 2:
                    message.decodes.push(Codec.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AudioCodecs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated stream.video.sfu.models_v1.Codec encodes = 1; */
        for (let i = 0; i < message.encodes.length; i++)
            Codec.internalBinaryWrite(message.encodes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated stream.video.sfu.models_v1.Codec decodes = 2; */
        for (let i = 0; i < message.decodes.length; i++)
            Codec.internalBinaryWrite(message.decodes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.sfu.models_v1.AudioCodecs
 */
export const AudioCodecs = new AudioCodecs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VideoCodecs$Type extends MessageType<VideoCodecs> {
    constructor() {
        super("stream.video.sfu.models_v1.VideoCodecs", [
            { no: 1, name: "encodes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Codec },
            { no: 2, name: "decodes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Codec }
        ]);
    }
    create(value?: PartialMessage<VideoCodecs>): VideoCodecs {
        const message = { encodes: [], decodes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VideoCodecs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VideoCodecs): VideoCodecs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated stream.video.sfu.models_v1.Codec encodes */ 1:
                    message.encodes.push(Codec.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated stream.video.sfu.models_v1.Codec decodes */ 2:
                    message.decodes.push(Codec.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VideoCodecs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated stream.video.sfu.models_v1.Codec encodes = 1; */
        for (let i = 0; i < message.encodes.length; i++)
            Codec.internalBinaryWrite(message.encodes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated stream.video.sfu.models_v1.Codec decodes = 2; */
        for (let i = 0; i < message.decodes.length; i++)
            Codec.internalBinaryWrite(message.decodes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.sfu.models_v1.VideoCodecs
 */
export const VideoCodecs = new VideoCodecs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CodecSettings$Type extends MessageType<CodecSettings> {
    constructor() {
        super("stream.video.sfu.models_v1.CodecSettings", [
            { no: 1, name: "audio", kind: "message", T: () => AudioCodecs },
            { no: 2, name: "video", kind: "message", T: () => VideoCodecs },
            { no: 3, name: "layers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VideoLayer }
        ]);
    }
    create(value?: PartialMessage<CodecSettings>): CodecSettings {
        const message = { layers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CodecSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CodecSettings): CodecSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.video.sfu.models_v1.AudioCodecs audio */ 1:
                    message.audio = AudioCodecs.internalBinaryRead(reader, reader.uint32(), options, message.audio);
                    break;
                case /* stream.video.sfu.models_v1.VideoCodecs video */ 2:
                    message.video = VideoCodecs.internalBinaryRead(reader, reader.uint32(), options, message.video);
                    break;
                case /* repeated stream.video.sfu.models_v1.VideoLayer layers */ 3:
                    message.layers.push(VideoLayer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CodecSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.video.sfu.models_v1.AudioCodecs audio = 1; */
        if (message.audio)
            AudioCodecs.internalBinaryWrite(message.audio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* stream.video.sfu.models_v1.VideoCodecs video = 2; */
        if (message.video)
            VideoCodecs.internalBinaryWrite(message.video, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated stream.video.sfu.models_v1.VideoLayer layers = 3; */
        for (let i = 0; i < message.layers.length; i++)
            VideoLayer.internalBinaryWrite(message.layers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.sfu.models_v1.CodecSettings
 */
export const CodecSettings = new CodecSettings$Type();
