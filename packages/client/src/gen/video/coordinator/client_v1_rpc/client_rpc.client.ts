/* eslint-disable */
// @generated by protobuf-ts 2.7.0 with parameter long_type_string,generate_dependencies,client_generic,server_none,eslint_disable
// @generated from protobuf file "video/coordinator/client_v1_rpc/client_rpc.proto" (package "stream.video.coordinator.client_v1_rpc", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { ClientRPC } from "./client_rpc";
import type { ReportIssueResponse } from "./client_rpc";
import type { ReportIssueRequest } from "./client_rpc";
import type { ReviewCallResponse } from "./client_rpc";
import type { ReviewCallRequest } from "./client_rpc";
import type { GetCallStatsResponse } from "./client_rpc";
import type { GetCallStatsRequest } from "./client_rpc";
import type { ReportCallStatsResponse } from "./client_rpc";
import type { ReportCallStatsRequest } from "./client_rpc";
import type { SendCustomEventResponse } from "./client_rpc";
import type { SendCustomEventRequest } from "./client_rpc";
import type { SendEventResponse } from "./client_rpc";
import type { SendEventRequest } from "./client_rpc";
import type { ListDevicesResponse } from "./client_rpc";
import type { ListDevicesRequest } from "./client_rpc";
import type { RemoveDeviceResponse } from "./client_rpc";
import type { RemoveDeviceRequest } from "./client_rpc";
import type { AddDeviceResponse } from "./client_rpc";
import type { AddDeviceRequest } from "./client_rpc";
import type { SelectEdgeServerResponse } from "./client_rpc";
import type { SelectEdgeServerRequest } from "./client_rpc";
import type { EndCallResponse } from "./client_rpc";
import type { EndCallRequest } from "./client_rpc";
import type { LeaveCallResponse } from "./client_rpc";
import type { LeaveCallRequest } from "./client_rpc";
import type { JoinCallResponse } from "./client_rpc";
import type { JoinCallRequest } from "./client_rpc";
import type { DeleteCallResponse } from "./client_rpc";
import type { DeleteCallRequest } from "./client_rpc";
import type { UpdateCallResponse } from "./client_rpc";
import type { UpdateCallRequest } from "./client_rpc";
import type { QueryCallsResponse } from "./client_rpc";
import type { QueryCallsRequest } from "./client_rpc";
import type { GetCallResponse } from "./client_rpc";
import type { GetCallRequest } from "./client_rpc";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { CreateCallResponse } from "./client_rpc";
import type { CreateCallRequest } from "./client_rpc";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service stream.video.coordinator.client_v1_rpc.ClientRPC
 */
export interface IClientRPCClient {
    /**
     * CreateCall creates a new call that is unique for the combination of type and id fields
     * If a call with the same type and id already exists then the call will be updated based on the request (if allowed and if needed)
     * The user calling this endpoint will be created if necessary ({id: id})
     * The users listed in the participants field will also be created if necessary ({id: id})
     *
     * @generated from protobuf rpc: CreateCall(stream.video.coordinator.client_v1_rpc.CreateCallRequest) returns (stream.video.coordinator.client_v1_rpc.CreateCallResponse);
     */
    createCall(input: CreateCallRequest, options?: RpcOptions): UnaryCall<CreateCallRequest, CreateCallResponse>;
    /**
     * GetCall retrieves the state for one call, the user calling this endpoint is created if missing
     *
     * @generated from protobuf rpc: GetCall(stream.video.coordinator.client_v1_rpc.GetCallRequest) returns (stream.video.coordinator.client_v1_rpc.GetCallResponse);
     */
    getCall(input: GetCallRequest, options?: RpcOptions): UnaryCall<GetCallRequest, GetCallResponse>;
    /**
     * @generated from protobuf rpc: QueryCalls(stream.video.coordinator.client_v1_rpc.QueryCallsRequest) returns (stream.video.coordinator.client_v1_rpc.QueryCallsResponse);
     */
    queryCalls(input: QueryCallsRequest, options?: RpcOptions): UnaryCall<QueryCallsRequest, QueryCallsResponse>;
    /**
     * @generated from protobuf rpc: UpdateCall(stream.video.coordinator.client_v1_rpc.UpdateCallRequest) returns (stream.video.coordinator.client_v1_rpc.UpdateCallResponse);
     */
    updateCall(input: UpdateCallRequest, options?: RpcOptions): UnaryCall<UpdateCallRequest, UpdateCallResponse>;
    /**
     * @generated from protobuf rpc: DeleteCall(stream.video.coordinator.client_v1_rpc.DeleteCallRequest) returns (stream.video.coordinator.client_v1_rpc.DeleteCallResponse);
     */
    deleteCall(input: DeleteCallRequest, options?: RpcOptions): UnaryCall<DeleteCallRequest, DeleteCallResponse>;
    /**
     * JoinCall returns the call state and the list of edges that the user should be check for latency
     * this endpoint is meant to be used to prepare the information needed to call the SelectEdgeServer endpoint
     *
     * @generated from protobuf rpc: JoinCall(stream.video.coordinator.client_v1_rpc.JoinCallRequest) returns (stream.video.coordinator.client_v1_rpc.JoinCallResponse);
     */
    joinCall(input: JoinCallRequest, options?: RpcOptions): UnaryCall<JoinCallRequest, JoinCallResponse>;
    /**
     * @generated from protobuf rpc: LeaveCall(stream.video.coordinator.client_v1_rpc.LeaveCallRequest) returns (stream.video.coordinator.client_v1_rpc.LeaveCallResponse);
     */
    leaveCall(input: LeaveCallRequest, options?: RpcOptions): UnaryCall<LeaveCallRequest, LeaveCallResponse>;
    /**
     * @generated from protobuf rpc: EndCall(stream.video.coordinator.client_v1_rpc.EndCallRequest) returns (stream.video.coordinator.client_v1_rpc.EndCallResponse);
     */
    endCall(input: EndCallRequest, options?: RpcOptions): UnaryCall<EndCallRequest, EndCallResponse>;
    /**
     * @generated from protobuf rpc: SelectEdgeServer(stream.video.coordinator.client_v1_rpc.SelectEdgeServerRequest) returns (stream.video.coordinator.client_v1_rpc.SelectEdgeServerResponse);
     */
    selectEdgeServer(input: SelectEdgeServerRequest, options?: RpcOptions): UnaryCall<SelectEdgeServerRequest, SelectEdgeServerResponse>;
    /**
     * AddDevice registers the mobile device for push notifications
     * this endpoint will create the user if missing
     * if a device with the same id and push_provider_name exists, then the operation will be ignored
     *
     * @generated from protobuf rpc: AddDevice(stream.video.coordinator.client_v1_rpc.AddDeviceRequest) returns (stream.video.coordinator.client_v1_rpc.AddDeviceResponse);
     */
    addDevice(input: AddDeviceRequest, options?: RpcOptions): UnaryCall<AddDeviceRequest, AddDeviceResponse>;
    /**
     * @generated from protobuf rpc: RemoveDevice(stream.video.coordinator.client_v1_rpc.RemoveDeviceRequest) returns (stream.video.coordinator.client_v1_rpc.RemoveDeviceResponse);
     */
    removeDevice(input: RemoveDeviceRequest, options?: RpcOptions): UnaryCall<RemoveDeviceRequest, RemoveDeviceResponse>;
    /**
     * @generated from protobuf rpc: ListDevices(stream.video.coordinator.client_v1_rpc.ListDevicesRequest) returns (stream.video.coordinator.client_v1_rpc.ListDevicesResponse);
     */
    listDevices(input: ListDevicesRequest, options?: RpcOptions): UnaryCall<ListDevicesRequest, ListDevicesResponse>;
    /**
     * add reaction should perhaps just be handled by chat
     *
     * @generated from protobuf rpc: SendEvent(stream.video.coordinator.client_v1_rpc.SendEventRequest) returns (stream.video.coordinator.client_v1_rpc.SendEventResponse);
     */
    sendEvent(input: SendEventRequest, options?: RpcOptions): UnaryCall<SendEventRequest, SendEventResponse>;
    /**
     * @generated from protobuf rpc: SendCustomEvent(stream.video.coordinator.client_v1_rpc.SendCustomEventRequest) returns (stream.video.coordinator.client_v1_rpc.SendCustomEventResponse);
     */
    sendCustomEvent(input: SendCustomEventRequest, options?: RpcOptions): UnaryCall<SendCustomEventRequest, SendCustomEventResponse>;
    // room is a confusing name. better to call it breakout room
    // breakout rooms have their own audio/video track
    // breakout rooms have their own chat

    // *
    // TODO
    // rpc CreateBreakoutRoom(CreateBreakoutRoomRequest) returns (CreateBreakoutRoomResponse);
    // rpc JoinBreakoutRoom() returns ();
    // rpc LeaveBreakoutRoom() returns ();
    // rpc DeleteBreakoutRoom() returns ();

    /**
     * endpoint for storing stats (perhaps we should move this to the SFU layer though)
     *
     * @generated from protobuf rpc: ReportCallStats(stream.video.coordinator.client_v1_rpc.ReportCallStatsRequest) returns (stream.video.coordinator.client_v1_rpc.ReportCallStatsResponse);
     */
    reportCallStats(input: ReportCallStatsRequest, options?: RpcOptions): UnaryCall<ReportCallStatsRequest, ReportCallStatsResponse>;
    /**
     * @generated from protobuf rpc: GetCallStats(stream.video.coordinator.client_v1_rpc.GetCallStatsRequest) returns (stream.video.coordinator.client_v1_rpc.GetCallStatsResponse);
     */
    getCallStats(input: GetCallStatsRequest, options?: RpcOptions): UnaryCall<GetCallStatsRequest, GetCallStatsResponse>;
    /**
     * endpoint for reviewing/rating the quality of calls
     *
     * @generated from protobuf rpc: ReviewCall(stream.video.coordinator.client_v1_rpc.ReviewCallRequest) returns (stream.video.coordinator.client_v1_rpc.ReviewCallResponse);
     */
    reviewCall(input: ReviewCallRequest, options?: RpcOptions): UnaryCall<ReviewCallRequest, ReviewCallResponse>;
    /**
     * endpoint for users to report issues with a call
     *
     * @generated from protobuf rpc: ReportIssue(stream.video.coordinator.client_v1_rpc.ReportIssueRequest) returns (stream.video.coordinator.client_v1_rpc.ReportIssueResponse);
     */
    reportIssue(input: ReportIssueRequest, options?: RpcOptions): UnaryCall<ReportIssueRequest, ReportIssueResponse>;
}
/**
 * @generated from protobuf service stream.video.coordinator.client_v1_rpc.ClientRPC
 */
export class ClientRPCClient implements IClientRPCClient, ServiceInfo {
    typeName = ClientRPC.typeName;
    methods = ClientRPC.methods;
    options = ClientRPC.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * CreateCall creates a new call that is unique for the combination of type and id fields
     * If a call with the same type and id already exists then the call will be updated based on the request (if allowed and if needed)
     * The user calling this endpoint will be created if necessary ({id: id})
     * The users listed in the participants field will also be created if necessary ({id: id})
     *
     * @generated from protobuf rpc: CreateCall(stream.video.coordinator.client_v1_rpc.CreateCallRequest) returns (stream.video.coordinator.client_v1_rpc.CreateCallResponse);
     */
    createCall(input: CreateCallRequest, options?: RpcOptions): UnaryCall<CreateCallRequest, CreateCallResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateCallRequest, CreateCallResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetCall retrieves the state for one call, the user calling this endpoint is created if missing
     *
     * @generated from protobuf rpc: GetCall(stream.video.coordinator.client_v1_rpc.GetCallRequest) returns (stream.video.coordinator.client_v1_rpc.GetCallResponse);
     */
    getCall(input: GetCallRequest, options?: RpcOptions): UnaryCall<GetCallRequest, GetCallResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetCallRequest, GetCallResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: QueryCalls(stream.video.coordinator.client_v1_rpc.QueryCallsRequest) returns (stream.video.coordinator.client_v1_rpc.QueryCallsResponse);
     */
    queryCalls(input: QueryCallsRequest, options?: RpcOptions): UnaryCall<QueryCallsRequest, QueryCallsResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryCallsRequest, QueryCallsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: UpdateCall(stream.video.coordinator.client_v1_rpc.UpdateCallRequest) returns (stream.video.coordinator.client_v1_rpc.UpdateCallResponse);
     */
    updateCall(input: UpdateCallRequest, options?: RpcOptions): UnaryCall<UpdateCallRequest, UpdateCallResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateCallRequest, UpdateCallResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: DeleteCall(stream.video.coordinator.client_v1_rpc.DeleteCallRequest) returns (stream.video.coordinator.client_v1_rpc.DeleteCallResponse);
     */
    deleteCall(input: DeleteCallRequest, options?: RpcOptions): UnaryCall<DeleteCallRequest, DeleteCallResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteCallRequest, DeleteCallResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * JoinCall returns the call state and the list of edges that the user should be check for latency
     * this endpoint is meant to be used to prepare the information needed to call the SelectEdgeServer endpoint
     *
     * @generated from protobuf rpc: JoinCall(stream.video.coordinator.client_v1_rpc.JoinCallRequest) returns (stream.video.coordinator.client_v1_rpc.JoinCallResponse);
     */
    joinCall(input: JoinCallRequest, options?: RpcOptions): UnaryCall<JoinCallRequest, JoinCallResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<JoinCallRequest, JoinCallResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: LeaveCall(stream.video.coordinator.client_v1_rpc.LeaveCallRequest) returns (stream.video.coordinator.client_v1_rpc.LeaveCallResponse);
     */
    leaveCall(input: LeaveCallRequest, options?: RpcOptions): UnaryCall<LeaveCallRequest, LeaveCallResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<LeaveCallRequest, LeaveCallResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: EndCall(stream.video.coordinator.client_v1_rpc.EndCallRequest) returns (stream.video.coordinator.client_v1_rpc.EndCallResponse);
     */
    endCall(input: EndCallRequest, options?: RpcOptions): UnaryCall<EndCallRequest, EndCallResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<EndCallRequest, EndCallResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: SelectEdgeServer(stream.video.coordinator.client_v1_rpc.SelectEdgeServerRequest) returns (stream.video.coordinator.client_v1_rpc.SelectEdgeServerResponse);
     */
    selectEdgeServer(input: SelectEdgeServerRequest, options?: RpcOptions): UnaryCall<SelectEdgeServerRequest, SelectEdgeServerResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<SelectEdgeServerRequest, SelectEdgeServerResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * AddDevice registers the mobile device for push notifications
     * this endpoint will create the user if missing
     * if a device with the same id and push_provider_name exists, then the operation will be ignored
     *
     * @generated from protobuf rpc: AddDevice(stream.video.coordinator.client_v1_rpc.AddDeviceRequest) returns (stream.video.coordinator.client_v1_rpc.AddDeviceResponse);
     */
    addDevice(input: AddDeviceRequest, options?: RpcOptions): UnaryCall<AddDeviceRequest, AddDeviceResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<AddDeviceRequest, AddDeviceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: RemoveDevice(stream.video.coordinator.client_v1_rpc.RemoveDeviceRequest) returns (stream.video.coordinator.client_v1_rpc.RemoveDeviceResponse);
     */
    removeDevice(input: RemoveDeviceRequest, options?: RpcOptions): UnaryCall<RemoveDeviceRequest, RemoveDeviceResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<RemoveDeviceRequest, RemoveDeviceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: ListDevices(stream.video.coordinator.client_v1_rpc.ListDevicesRequest) returns (stream.video.coordinator.client_v1_rpc.ListDevicesResponse);
     */
    listDevices(input: ListDevicesRequest, options?: RpcOptions): UnaryCall<ListDevicesRequest, ListDevicesResponse> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListDevicesRequest, ListDevicesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * add reaction should perhaps just be handled by chat
     *
     * @generated from protobuf rpc: SendEvent(stream.video.coordinator.client_v1_rpc.SendEventRequest) returns (stream.video.coordinator.client_v1_rpc.SendEventResponse);
     */
    sendEvent(input: SendEventRequest, options?: RpcOptions): UnaryCall<SendEventRequest, SendEventResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<SendEventRequest, SendEventResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: SendCustomEvent(stream.video.coordinator.client_v1_rpc.SendCustomEventRequest) returns (stream.video.coordinator.client_v1_rpc.SendCustomEventResponse);
     */
    sendCustomEvent(input: SendCustomEventRequest, options?: RpcOptions): UnaryCall<SendCustomEventRequest, SendCustomEventResponse> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<SendCustomEventRequest, SendCustomEventResponse>("unary", this._transport, method, opt, input);
    }
    // room is a confusing name. better to call it breakout room
    // breakout rooms have their own audio/video track
    // breakout rooms have their own chat

    // *
    // TODO
    // rpc CreateBreakoutRoom(CreateBreakoutRoomRequest) returns (CreateBreakoutRoomResponse);
    // rpc JoinBreakoutRoom() returns ();
    // rpc LeaveBreakoutRoom() returns ();
    // rpc DeleteBreakoutRoom() returns ();

    /**
     * endpoint for storing stats (perhaps we should move this to the SFU layer though)
     *
     * @generated from protobuf rpc: ReportCallStats(stream.video.coordinator.client_v1_rpc.ReportCallStatsRequest) returns (stream.video.coordinator.client_v1_rpc.ReportCallStatsResponse);
     */
    reportCallStats(input: ReportCallStatsRequest, options?: RpcOptions): UnaryCall<ReportCallStatsRequest, ReportCallStatsResponse> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReportCallStatsRequest, ReportCallStatsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: GetCallStats(stream.video.coordinator.client_v1_rpc.GetCallStatsRequest) returns (stream.video.coordinator.client_v1_rpc.GetCallStatsResponse);
     */
    getCallStats(input: GetCallStatsRequest, options?: RpcOptions): UnaryCall<GetCallStatsRequest, GetCallStatsResponse> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetCallStatsRequest, GetCallStatsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * endpoint for reviewing/rating the quality of calls
     *
     * @generated from protobuf rpc: ReviewCall(stream.video.coordinator.client_v1_rpc.ReviewCallRequest) returns (stream.video.coordinator.client_v1_rpc.ReviewCallResponse);
     */
    reviewCall(input: ReviewCallRequest, options?: RpcOptions): UnaryCall<ReviewCallRequest, ReviewCallResponse> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReviewCallRequest, ReviewCallResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * endpoint for users to report issues with a call
     *
     * @generated from protobuf rpc: ReportIssue(stream.video.coordinator.client_v1_rpc.ReportIssueRequest) returns (stream.video.coordinator.client_v1_rpc.ReportIssueResponse);
     */
    reportIssue(input: ReportIssueRequest, options?: RpcOptions): UnaryCall<ReportIssueRequest, ReportIssueResponse> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReportIssueRequest, ReportIssueResponse>("unary", this._transport, method, opt, input);
    }
}
