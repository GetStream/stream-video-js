/* eslint-disable */
// @generated by protobuf-ts 2.8.1 with parameter long_type_string,client_generic,server_none,eslint_disable
// @generated from protobuf file "video/coordinator/client_v1_rpc/envelopes.proto" (package "stream.video.coordinator.client_v1_rpc", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Member } from "../member_v1/member";
import { CallDetails } from "../call_v1/call";
import { Call } from "../call_v1/call";
import { User } from "../user_v1/user";
/**
 * CallEnvelope contains Call and all related information to it
 * Only used in reponse types that return a single call
 *
 * @generated from protobuf message stream.video.coordinator.client_v1_rpc.CallEnvelope
 */
export interface CallEnvelope {
    /**
     * All users referenced in the response
     *
     * @generated from protobuf field: map<string, stream.video.coordinator.user_v1.User> users = 1;
     */
    users: {
        [key: string]: User;
    };
    /**
     * Call object
     *
     * @generated from protobuf field: stream.video.coordinator.call_v1.Call call = 2;
     */
    call?: Call;
    /**
     * Call details
     *
     * @generated from protobuf field: stream.video.coordinator.call_v1.CallDetails details = 3;
     */
    details?: CallDetails;
}
/**
 * CallsEnvelope contains list of calls and all related information to them
 * Only used in response types that return list of calls
 *
 * @generated from protobuf message stream.video.coordinator.client_v1_rpc.CallsEnvelope
 */
export interface CallsEnvelope {
    /**
     * All users referenced in the response
     *
     * @generated from protobuf field: map<string, stream.video.coordinator.user_v1.User> users = 1;
     */
    users: {
        [key: string]: User;
    };
    /**
     * Ordered list of Call.call_cid
     *
     * @generated from protobuf field: repeated string call_cids = 2;
     */
    callCids: string[];
    /**
     * Call objects, indexed by Call.call_cid
     *
     * @generated from protobuf field: map<string, stream.video.coordinator.call_v1.Call> calls = 3;
     */
    calls: {
        [key: string]: Call;
    };
    /**
     * Call details, indexed by Call.call_cid
     *
     * @generated from protobuf field: map<string, stream.video.coordinator.call_v1.CallDetails> details = 4;
     */
    details: {
        [key: string]: CallDetails;
    };
}
/**
 * CallsEnvelope contains list of members and all related information to them
 * Only used in response types that return list of members
 *
 * @generated from protobuf message stream.video.coordinator.client_v1_rpc.MembersEnvelope
 */
export interface MembersEnvelope {
    /**
     * All users referenced in the response
     *
     * @generated from protobuf field: map<string, stream.video.coordinator.user_v1.User> users = 1;
     */
    users: {
        [key: string]: User;
    };
    /**
     * Ordered list of Member.user_id
     *
     * @generated from protobuf field: repeated string member_user_ids = 2;
     */
    memberUserIds: string[];
    /**
     * Map of members indexed by Member.user_id
     *
     * @generated from protobuf field: map<string, stream.video.coordinator.member_v1.Member> members = 3;
     */
    members: {
        [key: string]: Member;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class CallEnvelope$Type extends MessageType<CallEnvelope> {
    constructor() {
        super("stream.video.coordinator.client_v1_rpc.CallEnvelope", [
            { no: 1, name: "users", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => User } },
            { no: 2, name: "call", kind: "message", T: () => Call },
            { no: 3, name: "details", kind: "message", T: () => CallDetails }
        ]);
    }
    create(value?: PartialMessage<CallEnvelope>): CallEnvelope {
        const message = { users: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CallEnvelope>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CallEnvelope): CallEnvelope {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, stream.video.coordinator.user_v1.User> users */ 1:
                    this.binaryReadMap1(message.users, reader, options);
                    break;
                case /* stream.video.coordinator.call_v1.Call call */ 2:
                    message.call = Call.internalBinaryRead(reader, reader.uint32(), options, message.call);
                    break;
                case /* stream.video.coordinator.call_v1.CallDetails details */ 3:
                    message.details = CallDetails.internalBinaryRead(reader, reader.uint32(), options, message.details);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CallEnvelope["users"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CallEnvelope["users"] | undefined, val: CallEnvelope["users"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = User.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field stream.video.coordinator.client_v1_rpc.CallEnvelope.users");
            }
        }
        map[key ?? ""] = val ?? User.create();
    }
    internalBinaryWrite(message: CallEnvelope, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, stream.video.coordinator.user_v1.User> users = 1; */
        for (let k of Object.keys(message.users)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            User.internalBinaryWrite(message.users[k], writer, options);
            writer.join().join();
        }
        /* stream.video.coordinator.call_v1.Call call = 2; */
        if (message.call)
            Call.internalBinaryWrite(message.call, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* stream.video.coordinator.call_v1.CallDetails details = 3; */
        if (message.details)
            CallDetails.internalBinaryWrite(message.details, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.coordinator.client_v1_rpc.CallEnvelope
 */
export const CallEnvelope = new CallEnvelope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CallsEnvelope$Type extends MessageType<CallsEnvelope> {
    constructor() {
        super("stream.video.coordinator.client_v1_rpc.CallsEnvelope", [
            { no: 1, name: "users", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => User } },
            { no: 2, name: "call_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "calls", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Call } },
            { no: 4, name: "details", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CallDetails } }
        ]);
    }
    create(value?: PartialMessage<CallsEnvelope>): CallsEnvelope {
        const message = { users: {}, callCids: [], calls: {}, details: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CallsEnvelope>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CallsEnvelope): CallsEnvelope {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, stream.video.coordinator.user_v1.User> users */ 1:
                    this.binaryReadMap1(message.users, reader, options);
                    break;
                case /* repeated string call_cids */ 2:
                    message.callCids.push(reader.string());
                    break;
                case /* map<string, stream.video.coordinator.call_v1.Call> calls */ 3:
                    this.binaryReadMap3(message.calls, reader, options);
                    break;
                case /* map<string, stream.video.coordinator.call_v1.CallDetails> details */ 4:
                    this.binaryReadMap4(message.details, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CallsEnvelope["users"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CallsEnvelope["users"] | undefined, val: CallsEnvelope["users"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = User.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field stream.video.coordinator.client_v1_rpc.CallsEnvelope.users");
            }
        }
        map[key ?? ""] = val ?? User.create();
    }
    private binaryReadMap3(map: CallsEnvelope["calls"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CallsEnvelope["calls"] | undefined, val: CallsEnvelope["calls"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Call.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field stream.video.coordinator.client_v1_rpc.CallsEnvelope.calls");
            }
        }
        map[key ?? ""] = val ?? Call.create();
    }
    private binaryReadMap4(map: CallsEnvelope["details"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CallsEnvelope["details"] | undefined, val: CallsEnvelope["details"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CallDetails.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field stream.video.coordinator.client_v1_rpc.CallsEnvelope.details");
            }
        }
        map[key ?? ""] = val ?? CallDetails.create();
    }
    internalBinaryWrite(message: CallsEnvelope, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, stream.video.coordinator.user_v1.User> users = 1; */
        for (let k of Object.keys(message.users)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            User.internalBinaryWrite(message.users[k], writer, options);
            writer.join().join();
        }
        /* repeated string call_cids = 2; */
        for (let i = 0; i < message.callCids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.callCids[i]);
        /* map<string, stream.video.coordinator.call_v1.Call> calls = 3; */
        for (let k of Object.keys(message.calls)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Call.internalBinaryWrite(message.calls[k], writer, options);
            writer.join().join();
        }
        /* map<string, stream.video.coordinator.call_v1.CallDetails> details = 4; */
        for (let k of Object.keys(message.details)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CallDetails.internalBinaryWrite(message.details[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.coordinator.client_v1_rpc.CallsEnvelope
 */
export const CallsEnvelope = new CallsEnvelope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MembersEnvelope$Type extends MessageType<MembersEnvelope> {
    constructor() {
        super("stream.video.coordinator.client_v1_rpc.MembersEnvelope", [
            { no: 1, name: "users", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => User } },
            { no: 2, name: "member_user_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "members", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Member } }
        ]);
    }
    create(value?: PartialMessage<MembersEnvelope>): MembersEnvelope {
        const message = { users: {}, memberUserIds: [], members: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MembersEnvelope>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MembersEnvelope): MembersEnvelope {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, stream.video.coordinator.user_v1.User> users */ 1:
                    this.binaryReadMap1(message.users, reader, options);
                    break;
                case /* repeated string member_user_ids */ 2:
                    message.memberUserIds.push(reader.string());
                    break;
                case /* map<string, stream.video.coordinator.member_v1.Member> members */ 3:
                    this.binaryReadMap3(message.members, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MembersEnvelope["users"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MembersEnvelope["users"] | undefined, val: MembersEnvelope["users"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = User.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field stream.video.coordinator.client_v1_rpc.MembersEnvelope.users");
            }
        }
        map[key ?? ""] = val ?? User.create();
    }
    private binaryReadMap3(map: MembersEnvelope["members"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MembersEnvelope["members"] | undefined, val: MembersEnvelope["members"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Member.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field stream.video.coordinator.client_v1_rpc.MembersEnvelope.members");
            }
        }
        map[key ?? ""] = val ?? Member.create();
    }
    internalBinaryWrite(message: MembersEnvelope, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, stream.video.coordinator.user_v1.User> users = 1; */
        for (let k of Object.keys(message.users)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            User.internalBinaryWrite(message.users[k], writer, options);
            writer.join().join();
        }
        /* repeated string member_user_ids = 2; */
        for (let i = 0; i < message.memberUserIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.memberUserIds[i]);
        /* map<string, stream.video.coordinator.member_v1.Member> members = 3; */
        for (let k of Object.keys(message.members)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Member.internalBinaryWrite(message.members[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.coordinator.client_v1_rpc.MembersEnvelope
 */
export const MembersEnvelope = new MembersEnvelope$Type();
