/* eslint-disable */
// @generated by protobuf-ts 2.7.0 with parameter long_type_string,generate_dependencies,client_generic,server_none,eslint_disable
// @generated from protobuf file "permission_v1/permission.proto" (package "stream.video.permission_v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message stream.video.permission_v1.Permission
 */
export interface Permission {
    /**
     * The unique permission identifier.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The human readable version of the permission.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * The description of the permission.
     *
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * The action that this permission grants.
     *
     * @generated from protobuf field: stream.video.permission_v1.Action action = 4;
     */
    action: Action;
    /**
     * If true, the permission only applies if the user is the owner of the resource (eg. the creator of a call).
     *
     * @generated from protobuf field: bool owner = 5;
     */
    owner: boolean;
    /**
     * If true, the permission only applies if user and resource are from the same team.
     *
     * @generated from protobuf field: bool same_team = 6;
     */
    sameTeam: boolean;
}
/**
 * @generated from protobuf message stream.video.permission_v1.Permissions
 */
export interface Permissions {
    /**
     * @generated from protobuf field: repeated stream.video.permission_v1.Permission permissions = 1;
     */
    permissions: Permission[];
}
/**
 * @generated from protobuf message stream.video.permission_v1.Grant
 */
export interface Grant {
    /**
     * @generated from protobuf field: string call_type = 1;
     */
    callType: string;
    /**
     * If provided we store this at the call level and merge with call_type.
     *
     * @generated from protobuf field: string call_id = 2;
     */
    callId: string;
    /**
     * @generated from protobuf field: string role = 3;
     */
    role: string;
    /**
     * @generated from protobuf field: repeated stream.video.permission_v1.Action actions = 4;
     */
    actions: Action[];
}
/**
 * @generated from protobuf message stream.video.permission_v1.UserCapability
 */
export interface UserCapability {
    /**
     * @generated from protobuf field: string action = 1;
     */
    action: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
}
/**
 * @generated from protobuf enum stream.video.permission_v1.Action
 */
export enum Action {
    /**
     * @generated from protobuf enum value: ACTION_EMPTY_UNSPECIFIED = 0;
     */
    EMPTY_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ACTION_CREATE_CALL = 1;
     */
    CREATE_CALL = 1,
    /**
     * @generated from protobuf enum value: ACTION_DELETE_CALL = 2;
     */
    DELETE_CALL = 2,
    /**
     * @generated from protobuf enum value: ACTION_SCREENSHARE = 3;
     */
    SCREENSHARE = 3,
    /**
     * @generated from protobuf enum value: ACTION_RECORD_CALL = 4;
     */
    RECORD_CALL = 4,
    /**
     * @generated from protobuf enum value: ACTION_START_TRANSCRIBE = 5;
     */
    START_TRANSCRIBE = 5,
    /**
     * @generated from protobuf enum value: ACTION_RENAME_USER = 6;
     */
    RENAME_USER = 6,
    /**
     * @generated from protobuf enum value: ACTION_HIDE_PROFILE_PICTURES = 7;
     */
    HIDE_PROFILE_PICTURES = 7,
    /**
     * @generated from protobuf enum value: ACTION_UNMUTE = 8;
     */
    UNMUTE = 8,
    /**
     * @generated from protobuf enum value: ACTION_MUTE_OTHER_USER = 9;
     */
    MUTE_OTHER_USER = 9,
    /**
     * @generated from protobuf enum value: ACTION_START_VIDEO = 10;
     */
    START_VIDEO = 10,
    /**
     * @generated from protobuf enum value: ACTION_BROADCAST_CALL = 11;
     */
    BROADCAST_CALL = 11
}
// @generated message type with reflection information, may provide speed optimized methods
class Permission$Type extends MessageType<Permission> {
    constructor() {
        super("stream.video.permission_v1.Permission", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "action", kind: "enum", T: () => ["stream.video.permission_v1.Action", Action, "ACTION_"] },
            { no: 5, name: "owner", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "same_team", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Permission>): Permission {
        const message = { id: "", name: "", description: "", action: 0, owner: false, sameTeam: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Permission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Permission): Permission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* stream.video.permission_v1.Action action */ 4:
                    message.action = reader.int32();
                    break;
                case /* bool owner */ 5:
                    message.owner = reader.bool();
                    break;
                case /* bool same_team */ 6:
                    message.sameTeam = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Permission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* stream.video.permission_v1.Action action = 4; */
        if (message.action !== 0)
            writer.tag(4, WireType.Varint).int32(message.action);
        /* bool owner = 5; */
        if (message.owner !== false)
            writer.tag(5, WireType.Varint).bool(message.owner);
        /* bool same_team = 6; */
        if (message.sameTeam !== false)
            writer.tag(6, WireType.Varint).bool(message.sameTeam);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.permission_v1.Permission
 */
export const Permission = new Permission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Permissions$Type extends MessageType<Permissions> {
    constructor() {
        super("stream.video.permission_v1.Permissions", [
            { no: 1, name: "permissions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Permission }
        ]);
    }
    create(value?: PartialMessage<Permissions>): Permissions {
        const message = { permissions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Permissions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Permissions): Permissions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated stream.video.permission_v1.Permission permissions */ 1:
                    message.permissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Permissions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated stream.video.permission_v1.Permission permissions = 1; */
        for (let i = 0; i < message.permissions.length; i++)
            Permission.internalBinaryWrite(message.permissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.permission_v1.Permissions
 */
export const Permissions = new Permissions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Grant$Type extends MessageType<Grant> {
    constructor() {
        super("stream.video.permission_v1.Grant", [
            { no: 1, name: "call_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "call_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "actions", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["stream.video.permission_v1.Action", Action, "ACTION_"] }
        ]);
    }
    create(value?: PartialMessage<Grant>): Grant {
        const message = { callType: "", callId: "", role: "", actions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Grant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Grant): Grant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string call_type */ 1:
                    message.callType = reader.string();
                    break;
                case /* string call_id */ 2:
                    message.callId = reader.string();
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* repeated stream.video.permission_v1.Action actions */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.actions.push(reader.int32());
                    else
                        message.actions.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Grant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string call_type = 1; */
        if (message.callType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.callType);
        /* string call_id = 2; */
        if (message.callId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.callId);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* repeated stream.video.permission_v1.Action actions = 4; */
        if (message.actions.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.actions.length; i++)
                writer.int32(message.actions[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.permission_v1.Grant
 */
export const Grant = new Grant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserCapability$Type extends MessageType<UserCapability> {
    constructor() {
        super("stream.video.permission_v1.UserCapability", [
            { no: 1, name: "action", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserCapability>): UserCapability {
        const message = { action: "", description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserCapability>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserCapability): UserCapability {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string action */ 1:
                    message.action = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserCapability, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string action = 1; */
        if (message.action !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.action);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.permission_v1.UserCapability
 */
export const UserCapability = new UserCapability$Type();
