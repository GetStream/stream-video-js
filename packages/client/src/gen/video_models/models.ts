/* eslint-disable */
// @generated by protobuf-ts 2.7.0 with parameter long_type_string,generate_dependencies,client_generic,server_none,eslint_disable
// @generated from protobuf file "video_models/models.proto" (package "stream.video", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Struct } from "../google/protobuf/struct";
/**
 * Edges are where we deploy video servers
 *
 * @generated from protobuf message stream.video.Edge
 */
export interface Edge {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string latency_url = 2;
     */
    latencyUrl: string;
}
// TODO: to discuss. do we keep a log per call of
// - people joining
// - reactions
// - etc?
// - maybe it only makes sense when you transcribe the call

/**
 * Edges are where we deploy video servers
 *
 * @generated from protobuf message stream.video.EdgeServer
 */
export interface EdgeServer {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
}
/**
 * Returns information about the server location
 *
 * @generated from protobuf message stream.video.EdgeServer.Coordinates
 */
export interface EdgeServer_Coordinates {
    /**
     * @generated from protobuf field: float lat = 1;
     */
    lat: number;
    /**
     * @generated from protobuf field: float long = 2;
     */
    long: number;
}
/**
 * @generated from protobuf message stream.video.Latency
 */
export interface Latency {
    /**
     * @generated from protobuf field: repeated float measurements_seconds = 1;
     */
    measurementsSeconds: number[];
}
/**
 * @generated from protobuf message stream.video.File
 */
export interface File {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: bool composite = 2;
     */
    composite: boolean;
    /**
     * @generated from protobuf field: string user_id = 3;
     */
    userId: string;
    /**
     * @generated from protobuf field: string url = 4;
     */
    url: string;
}
/**
 * @generated from protobuf message stream.video.RecordBroadcast
 */
export interface RecordBroadcast {
    /**
     * @generated from protobuf field: bool composite = 1;
     */
    composite: boolean; // if true merge all audio and video, if false split them
    /**
     * @generated from protobuf field: repeated stream.video.File files = 2;
     */
    files: File[];
}
/**
 * @generated from protobuf message stream.video.User
 */
export interface User {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: repeated string teams = 2;
     */
    teams: string[];
    /**
     * @generated from protobuf field: string role = 3;
     */
    role: string;
    /**
     * @generated from protobuf field: google.protobuf.Struct custom = 4;
     */
    custom?: Struct;
    /**
     * @generated from protobuf field: string name = 5;
     */
    name: string;
    /**
     * @generated from protobuf field: string image_url = 6;
     */
    imageUrl: string;
    /**
     * user creation date as RFC3339 string
     *
     * @generated from protobuf field: string created_at = 7;
     */
    createdAt: string;
    /**
     * user last update date as RFC3339 string
     *
     * @generated from protobuf field: string updated_at = 8;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message stream.video.UserRequest
 */
export interface UserRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: repeated string teams = 2;
     */
    teams: string[];
    /**
     * @generated from protobuf field: string role = 3;
     */
    role: string;
    /**
     * @generated from protobuf field: google.protobuf.Struct custom = 4;
     */
    custom?: Struct;
    /**
     * @generated from protobuf field: string name = 5;
     */
    name: string;
    /**
     * @generated from protobuf field: string profile_image_url = 6;
     */
    profileImageUrl: string;
}
/**
 * @generated from protobuf message stream.video.Device
 */
export interface Device {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: bool disabled = 3;
     */
    disabled: boolean;
    /**
     * @generated from protobuf field: string disabled_reason = 4;
     */
    disabledReason: string;
    /**
     * @generated from protobuf field: string push_provider_name = 5;
     */
    pushProviderName: string;
    /**
     * @generated from protobuf field: string created_at = 6;
     */
    createdAt: string;
    /**
     * @generated from protobuf field: string updated_at = 7;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message stream.video.DeviceRequest
 */
export interface DeviceRequest {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: bool disabled = 3;
     */
    disabled: boolean;
    /**
     * @generated from protobuf field: string disabled_reason = 4;
     */
    disabledReason: string;
    /**
     * @generated from protobuf field: string push_provider_name = 5;
     */
    pushProviderName: string;
}
/**
 * @generated from protobuf message stream.video.RecordingStorageOptions
 */
export interface RecordingStorageOptions {
    /**
     * @generated from protobuf field: stream.video.RecordingStorage storage = 2;
     */
    storage: RecordingStorage;
    /**
     * @generated from protobuf field: string access_key = 3;
     */
    accessKey: string;
    /**
     * @generated from protobuf field: string secret_key = 4;
     */
    secretKey: string;
    /**
     * @generated from protobuf field: string bucket_name = 5;
     */
    bucketName: string;
    /**
     * @generated from protobuf field: string region = 6;
     */
    region: string;
    /**
     * @generated from protobuf field: string path = 7;
     */
    path: string;
}
/**
 * @generated from protobuf message stream.video.RTMPOptions
 */
export interface RTMPOptions {
    /**
     * @generated from protobuf field: repeated string urls = 1;
     */
    urls: string[];
}
/**
 * @generated from protobuf message stream.video.Broadcast
 */
export interface Broadcast {
    /**
     * @generated from protobuf field: stream.video.RTMPOptions rtmp = 1;
     */
    rtmp?: RTMPOptions;
    /**
     * @generated from protobuf field: string hls_url = 2;
     */
    hlsUrl: string;
}
/**
 * @generated from protobuf message stream.video.TranscribeOptions
 */
export interface TranscribeOptions {
}
/**
 * @generated from protobuf message stream.video.Permission
 */
export interface Permission {
    /**
     * the unique permission identifier
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * the human readable version of the permission
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * the description of the permission
     *
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * the action that this permission grants
     *
     * @generated from protobuf field: stream.video.Action action = 4;
     */
    action: Action;
    /**
     * if true, the permission only applies if the user is the owner of the resource (eg. the creator of a call)
     *
     * @generated from protobuf field: bool owner = 5;
     */
    owner: boolean;
    /**
     * if true, the permission only applies if user and resource are from the same team
     *
     * @generated from protobuf field: bool same_team = 6;
     */
    sameTeam: boolean;
}
/**
 * @generated from protobuf message stream.video.Permissions
 */
export interface Permissions {
    /**
     * @generated from protobuf field: repeated stream.video.Permission permissions = 1;
     */
    permissions: Permission[];
}
/**
 * @generated from protobuf message stream.video.Grant
 */
export interface Grant {
    /**
     * @generated from protobuf field: string call_type = 1;
     */
    callType: string;
    /**
     * if provided we store this at the call level and merge with call_type
     *
     * @generated from protobuf field: string call_id = 2;
     */
    callId: string;
    /**
     * @generated from protobuf field: string role = 3;
     */
    role: string;
    /**
     * @generated from protobuf field: repeated stream.video.Action actions = 5;
     */
    actions: Action[];
}
/**
 * @generated from protobuf message stream.video.Features
 */
export interface Features {
    /**
     * recording calls
     *
     * @generated from protobuf field: stream.video.FeatureToggle recording = 1;
     */
    recording: FeatureToggle;
    /**
     * HLS stream broadcast
     *
     * @generated from protobuf field: stream.video.FeatureToggle hls_broadcast = 3;
     */
    hlsBroadcast: FeatureToggle;
    /**
     * call transcription
     *
     * @generated from protobuf field: stream.video.FeatureToggle transcribe = 4;
     */
    transcribe: FeatureToggle;
    /**
     * @generated from protobuf field: stream.video.TranscribeOptions transcribe_options = 5;
     */
    transcribeOptions?: TranscribeOptions;
}
/**
 * @generated from protobuf message stream.video.CallType
 */
export interface CallType {
    /**
     * the unique name for the call type
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * the permissions set for this call type
     *
     * @generated from protobuf field: map<string, stream.video.Permissions> permissions = 2;
     */
    permissions: {
        [key: string]: Permissions;
    };
    /**
     * the features enabled by default for this type of calls
     *
     * @generated from protobuf field: stream.video.Features features = 3;
     */
    features?: Features;
    /**
     * @generated from protobuf field: string created_at = 4;
     */
    createdAt: string;
    /**
     * @generated from protobuf field: string updated_at = 5;
     */
    updatedAt: string;
}
/**
 * those who are online in the call
 *
 * @generated from protobuf message stream.video.Participant
 */
export interface Participant {
    /**
     * @generated from protobuf field: stream.video.User user = 1;
     */
    user?: User;
    /**
     * @generated from protobuf field: string role = 2;
     */
    role: string;
    /**
     * @generated from protobuf field: bool online = 3;
     */
    online: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Struct custom = 4;
     */
    custom?: Struct;
    /**
     * @generated from protobuf field: bool video = 5;
     */
    video: boolean;
    /**
     * @generated from protobuf field: bool audio = 6;
     */
    audio: boolean;
    /**
     * call creation date as RFC3339 string
     *
     * @generated from protobuf field: string created_at = 7;
     */
    createdAt: string;
    /**
     * call last update date as RFC3339 string
     *
     * @generated from protobuf field: string updated_at = 8;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message stream.video.ParticipantRequest
 */
export interface ParticipantRequest {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string role = 2;
     */
    role: string;
    /**
     * call custom data
     *
     * @generated from protobuf field: google.protobuf.Struct custom = 3;
     */
    custom?: Struct;
    /**
     * call creation date as RFC3339 string
     *
     * @generated from protobuf field: string created_at = 4;
     */
    createdAt: string;
    /**
     * call last update date as RFC3339 string
     *
     * @generated from protobuf field: string updated_at = 5;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message stream.video.CallState
 */
export interface CallState {
    /**
     * @generated from protobuf field: repeated stream.video.Participant participants = 1;
     */
    participants: Participant[];
}
/**
 * @generated from protobuf message stream.video.Call
 */
export interface Call {
    /**
     * the call type
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * the call id
     *
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * the id of the user that created this call
     *
     * @generated from protobuf field: string created_by_user_id = 3;
     */
    createdByUserId: string;
    /**
     * the id of the current host for this call
     *
     * @generated from protobuf field: string host_user_id = 4;
     */
    hostUserId: string;
    /**
     * @generated from protobuf field: google.protobuf.Struct custom = 5;
     */
    custom?: Struct;
    /**
     * call creation date as RFC3339 string
     *
     * @generated from protobuf field: string created_at = 6;
     */
    createdAt: string;
    /**
     * call last update date as RFC3339 string
     *
     * @generated from protobuf field: string updated_at = 7;
     */
    updatedAt: string;
    /**
     * when recording is true, calls are recorded on S3
     *
     * @generated from protobuf field: bool recording = 8;
     */
    recording: boolean;
    /**
     * broadcast settings for this call
     *
     * @generated from protobuf field: stream.video.Broadcast broadcast = 9;
     */
    broadcast?: Broadcast;
    /**
     * enable transcription by default
     *
     * @generated from protobuf field: bool transcribe = 10;
     */
    transcribe: boolean;
    /**
     * @generated from protobuf field: stream.video.TranscribeOptions transcribe_options = 11;
     */
    transcribeOptions?: TranscribeOptions;
}
/**
 * @generated from protobuf message stream.video.ApnSettings
 */
export interface ApnSettings {
    /**
     * @generated from protobuf field: string auth_key = 1;
     */
    authKey: string;
    /**
     * @generated from protobuf field: string key_id = 2;
     */
    keyId: string;
    /**
     * @generated from protobuf field: string apn_topic = 3;
     */
    apnTopic: string;
    /**
     * @generated from protobuf field: string team_id = 4;
     */
    teamId: string;
    /**
     * @generated from protobuf field: bool development = 5;
     */
    development: boolean;
}
/**
 * @generated from protobuf message stream.video.FirebaseSettings
 */
export interface FirebaseSettings {
    /**
     * @generated from protobuf field: string server_key = 1;
     */
    serverKey: string;
    /**
     * @generated from protobuf field: string credentials_json = 2;
     */
    credentialsJson: string;
}
/**
 * @generated from protobuf message stream.video.HuaweiSettings
 */
export interface HuaweiSettings {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string secret = 2;
     */
    secret: string;
}
/**
 * @generated from protobuf message stream.video.XiaomiSettings
 */
export interface XiaomiSettings {
    /**
     * @generated from protobuf field: string package_name = 1;
     */
    packageName: string;
    /**
     * @generated from protobuf field: string secret = 2;
     */
    secret: string;
}
/**
 * @generated from protobuf message stream.video.SqsSettings
 */
export interface SqsSettings {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
    /**
     * @generated from protobuf field: string key = 2;
     */
    key: string;
    /**
     * @generated from protobuf field: string secret = 3;
     */
    secret: string;
}
/**
 * @generated from protobuf message stream.video.PushProvider
 */
export interface PushProvider {
    /**
     * the name for this push provider, unique for this application
     * @example apn_production
     * @example firebase_staging
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: settings
     */
    settings: {
        oneofKind: "apnSettings";
        /**
         * apn push configs
         *
         * @generated from protobuf field: stream.video.ApnSettings apn_settings = 2;
         */
        apnSettings: ApnSettings;
    } | {
        oneofKind: "firebaseSettings";
        /**
         * firebase push configs
         *
         * @generated from protobuf field: stream.video.FirebaseSettings firebase_settings = 3;
         */
        firebaseSettings: FirebaseSettings;
    } | {
        oneofKind: "huaweiSettings";
        /**
         * huawei push configs
         *
         * @generated from protobuf field: stream.video.HuaweiSettings huawei_settings = 4;
         */
        huaweiSettings: HuaweiSettings;
    } | {
        oneofKind: "xiaomiSettings";
        /**
         * xiaomi push configs
         *
         * @generated from protobuf field: stream.video.XiaomiSettings xiaomi_settings = 5;
         */
        xiaomiSettings: XiaomiSettings;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: bool disabled = 6;
     */
    disabled: boolean;
}
/**
 * @generated from protobuf message stream.video.ApplicationSettings
 */
export interface ApplicationSettings {
    /**
     * the webhook URL
     *
     * @generated from protobuf field: string webhook_url = 1;
     */
    webhookUrl: string;
    /**
     * push providers configured
     *
     * @generated from protobuf field: repeated stream.video.PushProvider push_providers = 2;
     */
    pushProviders: PushProvider[];
    /**
     * sqs settings
     *
     * @generated from protobuf field: stream.video.SqsSettings sqs_settings = 3;
     */
    sqsSettings?: SqsSettings;
}
/**
 * @generated from protobuf enum stream.video.Codec
 */
export enum Codec {
    /**
     * @generated from protobuf enum value: CODEC_H264_UNSPECIFIED = 0;
     */
    H264_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: CODEC_VP8 = 1;
     */
    VP8 = 1,
    /**
     * @generated from protobuf enum value: CODEC_VP9 = 2;
     */
    VP9 = 2
}
/**
 * @generated from protobuf enum stream.video.RecordingStorage
 */
export enum RecordingStorage {
    /**
     * @generated from protobuf enum value: RECORDING_STORAGE_S3_UNSPECIFIED = 0;
     */
    S3_UNSPECIFIED = 0
}
/**
 * @generated from protobuf enum stream.video.Action
 */
export enum Action {
    /**
     * @generated from protobuf enum value: ACTION_EMPTY_UNSPECIFIED = 0;
     */
    EMPTY_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ACTION_CREATE_CALL = 1;
     */
    CREATE_CALL = 1,
    /**
     * @generated from protobuf enum value: ACTION_DELETE_CALL = 2;
     */
    DELETE_CALL = 2,
    /**
     * @generated from protobuf enum value: ACTION_SCREENSHARE = 3;
     */
    SCREENSHARE = 3,
    /**
     * @generated from protobuf enum value: ACTION_RECORD_CALL = 4;
     */
    RECORD_CALL = 4,
    /**
     * @generated from protobuf enum value: ACTION_START_TRANSCRIBE = 5;
     */
    START_TRANSCRIBE = 5,
    /**
     * @generated from protobuf enum value: ACTION_RENAME_USER = 6;
     */
    RENAME_USER = 6,
    /**
     * @generated from protobuf enum value: ACTION_HIDE_PROFILE_PICTURES = 7;
     */
    HIDE_PROFILE_PICTURES = 7,
    /**
     * @generated from protobuf enum value: ACTION_UNMUTE = 8;
     */
    UNMUTE = 8,
    /**
     * @generated from protobuf enum value: ACTION_MUTE_OTHER_USER = 9;
     */
    MUTE_OTHER_USER = 9,
    /**
     * @generated from protobuf enum value: ACTION_START_VIDEO = 10;
     */
    START_VIDEO = 10,
    /**
     * @generated from protobuf enum value: ACTION_BROADCAST_CALL = 11;
     */
    BROADCAST_CALL = 11
}
/**
 * @generated from protobuf enum stream.video.FeatureToggle
 */
export enum FeatureToggle {
    /**
     * the feature is available and enabled by default
     *
     * @generated from protobuf enum value: FEATURE_TOGGLE_FEATURE_FLAG_ENABLED_UNSPECIFIED = 0;
     */
    FEATURE_FLAG_ENABLED_UNSPECIFIED = 0,
    /**
     * the feature is available but needs to be turned on the call level
     *
     * @generated from protobuf enum value: FEATURE_TOGGLE_FEATURE_FLAG_AVAILABLE = 1;
     */
    FEATURE_FLAG_AVAILABLE = 1,
    /**
     * the feature is disabled and cannot be turned on
     *
     * @generated from protobuf enum value: FEATURE_TOGGLE_FEATURE_FLAG_DISABLED = 2;
     */
    FEATURE_FLAG_DISABLED = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Edge$Type extends MessageType<Edge> {
    constructor() {
        super("stream.video.Edge", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "latency_url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<Edge>): Edge {
        const message = { name: "", latencyUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Edge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Edge): Edge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string latency_url */ 2:
                    message.latencyUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Edge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string latency_url = 2; */
        if (message.latencyUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.latencyUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Edge
 */
export const Edge = new Edge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EdgeServer$Type extends MessageType<EdgeServer> {
    constructor() {
        super("stream.video.EdgeServer", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EdgeServer>): EdgeServer {
        const message = { url: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EdgeServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EdgeServer): EdgeServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EdgeServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.EdgeServer
 */
export const EdgeServer = new EdgeServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EdgeServer_Coordinates$Type extends MessageType<EdgeServer_Coordinates> {
    constructor() {
        super("stream.video.EdgeServer.Coordinates", [
            { no: 1, name: "lat", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "long", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<EdgeServer_Coordinates>): EdgeServer_Coordinates {
        const message = { lat: 0, long: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EdgeServer_Coordinates>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EdgeServer_Coordinates): EdgeServer_Coordinates {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float lat */ 1:
                    message.lat = reader.float();
                    break;
                case /* float long */ 2:
                    message.long = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EdgeServer_Coordinates, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float lat = 1; */
        if (message.lat !== 0)
            writer.tag(1, WireType.Bit32).float(message.lat);
        /* float long = 2; */
        if (message.long !== 0)
            writer.tag(2, WireType.Bit32).float(message.long);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.EdgeServer.Coordinates
 */
export const EdgeServer_Coordinates = new EdgeServer_Coordinates$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Latency$Type extends MessageType<Latency> {
    constructor() {
        super("stream.video.Latency", [
            { no: 1, name: "measurements_seconds", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Latency>): Latency {
        const message = { measurementsSeconds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Latency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Latency): Latency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float measurements_seconds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.measurementsSeconds.push(reader.float());
                    else
                        message.measurementsSeconds.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Latency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated float measurements_seconds = 1; */
        if (message.measurementsSeconds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.measurementsSeconds.length; i++)
                writer.float(message.measurementsSeconds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Latency
 */
export const Latency = new Latency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class File$Type extends MessageType<File> {
    constructor() {
        super("stream.video.File", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "composite", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<File>): File {
        const message = { type: "", composite: false, userId: "", url: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<File>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: File): File {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bool composite */ 2:
                    message.composite = reader.bool();
                    break;
                case /* string user_id */ 3:
                    message.userId = reader.string();
                    break;
                case /* string url */ 4:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: File, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* bool composite = 2; */
        if (message.composite !== false)
            writer.tag(2, WireType.Varint).bool(message.composite);
        /* string user_id = 3; */
        if (message.userId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        /* string url = 4; */
        if (message.url !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.File
 */
export const File = new File$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordBroadcast$Type extends MessageType<RecordBroadcast> {
    constructor() {
        super("stream.video.RecordBroadcast", [
            { no: 1, name: "composite", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "files", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => File }
        ]);
    }
    create(value?: PartialMessage<RecordBroadcast>): RecordBroadcast {
        const message = { composite: false, files: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RecordBroadcast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordBroadcast): RecordBroadcast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool composite */ 1:
                    message.composite = reader.bool();
                    break;
                case /* repeated stream.video.File files */ 2:
                    message.files.push(File.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordBroadcast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool composite = 1; */
        if (message.composite !== false)
            writer.tag(1, WireType.Varint).bool(message.composite);
        /* repeated stream.video.File files = 2; */
        for (let i = 0; i < message.files.length; i++)
            File.internalBinaryWrite(message.files[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.RecordBroadcast
 */
export const RecordBroadcast = new RecordBroadcast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("stream.video.User", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "teams", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "custom", kind: "message", T: () => Struct },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "image_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = { id: "", teams: [], role: "", name: "", imageUrl: "", createdAt: "", updatedAt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated string teams */ 2:
                    message.teams.push(reader.string());
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* google.protobuf.Struct custom */ 4:
                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* string image_url */ 6:
                    message.imageUrl = reader.string();
                    break;
                case /* string created_at */ 7:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 8:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated string teams = 2; */
        for (let i = 0; i < message.teams.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.teams[i]);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* google.protobuf.Struct custom = 4; */
        if (message.custom)
            Struct.internalBinaryWrite(message.custom, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* string image_url = 6; */
        if (message.imageUrl !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.imageUrl);
        /* string created_at = 7; */
        if (message.createdAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 8; */
        if (message.updatedAt !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserRequest$Type extends MessageType<UserRequest> {
    constructor() {
        super("stream.video.UserRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "teams", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "custom", kind: "message", T: () => Struct },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "profile_image_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserRequest>): UserRequest {
        const message = { id: "", teams: [], role: "", name: "", profileImageUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserRequest): UserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated string teams */ 2:
                    message.teams.push(reader.string());
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* google.protobuf.Struct custom */ 4:
                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* string profile_image_url */ 6:
                    message.profileImageUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated string teams = 2; */
        for (let i = 0; i < message.teams.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.teams[i]);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* google.protobuf.Struct custom = 4; */
        if (message.custom)
            Struct.internalBinaryWrite(message.custom, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* string profile_image_url = 6; */
        if (message.profileImageUrl !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.profileImageUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.UserRequest
 */
export const UserRequest = new UserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Device$Type extends MessageType<Device> {
    constructor() {
        super("stream.video.Device", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "disabled_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "push_provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Device>): Device {
        const message = { userId: "", id: "", disabled: false, disabledReason: "", pushProviderName: "", createdAt: "", updatedAt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Device>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Device): Device {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* bool disabled */ 3:
                    message.disabled = reader.bool();
                    break;
                case /* string disabled_reason */ 4:
                    message.disabledReason = reader.string();
                    break;
                case /* string push_provider_name */ 5:
                    message.pushProviderName = reader.string();
                    break;
                case /* string created_at */ 6:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 7:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Device, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* bool disabled = 3; */
        if (message.disabled !== false)
            writer.tag(3, WireType.Varint).bool(message.disabled);
        /* string disabled_reason = 4; */
        if (message.disabledReason !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.disabledReason);
        /* string push_provider_name = 5; */
        if (message.pushProviderName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pushProviderName);
        /* string created_at = 6; */
        if (message.createdAt !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 7; */
        if (message.updatedAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Device
 */
export const Device = new Device$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceRequest$Type extends MessageType<DeviceRequest> {
    constructor() {
        super("stream.video.DeviceRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "disabled_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "push_provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeviceRequest>): DeviceRequest {
        const message = { userId: "", id: "", disabled: false, disabledReason: "", pushProviderName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceRequest): DeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* bool disabled */ 3:
                    message.disabled = reader.bool();
                    break;
                case /* string disabled_reason */ 4:
                    message.disabledReason = reader.string();
                    break;
                case /* string push_provider_name */ 5:
                    message.pushProviderName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* bool disabled = 3; */
        if (message.disabled !== false)
            writer.tag(3, WireType.Varint).bool(message.disabled);
        /* string disabled_reason = 4; */
        if (message.disabledReason !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.disabledReason);
        /* string push_provider_name = 5; */
        if (message.pushProviderName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pushProviderName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.DeviceRequest
 */
export const DeviceRequest = new DeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingStorageOptions$Type extends MessageType<RecordingStorageOptions> {
    constructor() {
        super("stream.video.RecordingStorageOptions", [
            { no: 2, name: "storage", kind: "enum", T: () => ["stream.video.RecordingStorage", RecordingStorage, "RECORDING_STORAGE_"] },
            { no: 3, name: "access_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "secret_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RecordingStorageOptions>): RecordingStorageOptions {
        const message = { storage: 0, accessKey: "", secretKey: "", bucketName: "", region: "", path: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RecordingStorageOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordingStorageOptions): RecordingStorageOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.video.RecordingStorage storage */ 2:
                    message.storage = reader.int32();
                    break;
                case /* string access_key */ 3:
                    message.accessKey = reader.string();
                    break;
                case /* string secret_key */ 4:
                    message.secretKey = reader.string();
                    break;
                case /* string bucket_name */ 5:
                    message.bucketName = reader.string();
                    break;
                case /* string region */ 6:
                    message.region = reader.string();
                    break;
                case /* string path */ 7:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordingStorageOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.video.RecordingStorage storage = 2; */
        if (message.storage !== 0)
            writer.tag(2, WireType.Varint).int32(message.storage);
        /* string access_key = 3; */
        if (message.accessKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accessKey);
        /* string secret_key = 4; */
        if (message.secretKey !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.secretKey);
        /* string bucket_name = 5; */
        if (message.bucketName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.bucketName);
        /* string region = 6; */
        if (message.region !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.region);
        /* string path = 7; */
        if (message.path !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.RecordingStorageOptions
 */
export const RecordingStorageOptions = new RecordingStorageOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RTMPOptions$Type extends MessageType<RTMPOptions> {
    constructor() {
        super("stream.video.RTMPOptions", [
            { no: 1, name: "urls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RTMPOptions>): RTMPOptions {
        const message = { urls: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RTMPOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RTMPOptions): RTMPOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string urls */ 1:
                    message.urls.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RTMPOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string urls = 1; */
        for (let i = 0; i < message.urls.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.urls[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.RTMPOptions
 */
export const RTMPOptions = new RTMPOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Broadcast$Type extends MessageType<Broadcast> {
    constructor() {
        super("stream.video.Broadcast", [
            { no: 1, name: "rtmp", kind: "message", T: () => RTMPOptions },
            { no: 2, name: "hls_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Broadcast>): Broadcast {
        const message = { hlsUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Broadcast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Broadcast): Broadcast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.video.RTMPOptions rtmp */ 1:
                    message.rtmp = RTMPOptions.internalBinaryRead(reader, reader.uint32(), options, message.rtmp);
                    break;
                case /* string hls_url */ 2:
                    message.hlsUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Broadcast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.video.RTMPOptions rtmp = 1; */
        if (message.rtmp)
            RTMPOptions.internalBinaryWrite(message.rtmp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string hls_url = 2; */
        if (message.hlsUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hlsUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Broadcast
 */
export const Broadcast = new Broadcast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranscribeOptions$Type extends MessageType<TranscribeOptions> {
    constructor() {
        super("stream.video.TranscribeOptions", []);
    }
    create(value?: PartialMessage<TranscribeOptions>): TranscribeOptions {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TranscribeOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranscribeOptions): TranscribeOptions {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TranscribeOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.TranscribeOptions
 */
export const TranscribeOptions = new TranscribeOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Permission$Type extends MessageType<Permission> {
    constructor() {
        super("stream.video.Permission", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "action", kind: "enum", T: () => ["stream.video.Action", Action, "ACTION_"] },
            { no: 5, name: "owner", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "same_team", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Permission>): Permission {
        const message = { id: "", name: "", description: "", action: 0, owner: false, sameTeam: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Permission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Permission): Permission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* stream.video.Action action */ 4:
                    message.action = reader.int32();
                    break;
                case /* bool owner */ 5:
                    message.owner = reader.bool();
                    break;
                case /* bool same_team */ 6:
                    message.sameTeam = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Permission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* stream.video.Action action = 4; */
        if (message.action !== 0)
            writer.tag(4, WireType.Varint).int32(message.action);
        /* bool owner = 5; */
        if (message.owner !== false)
            writer.tag(5, WireType.Varint).bool(message.owner);
        /* bool same_team = 6; */
        if (message.sameTeam !== false)
            writer.tag(6, WireType.Varint).bool(message.sameTeam);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Permission
 */
export const Permission = new Permission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Permissions$Type extends MessageType<Permissions> {
    constructor() {
        super("stream.video.Permissions", [
            { no: 1, name: "permissions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Permission }
        ]);
    }
    create(value?: PartialMessage<Permissions>): Permissions {
        const message = { permissions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Permissions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Permissions): Permissions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated stream.video.Permission permissions */ 1:
                    message.permissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Permissions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated stream.video.Permission permissions = 1; */
        for (let i = 0; i < message.permissions.length; i++)
            Permission.internalBinaryWrite(message.permissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Permissions
 */
export const Permissions = new Permissions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Grant$Type extends MessageType<Grant> {
    constructor() {
        super("stream.video.Grant", [
            { no: 1, name: "call_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "call_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "actions", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["stream.video.Action", Action, "ACTION_"] }
        ]);
    }
    create(value?: PartialMessage<Grant>): Grant {
        const message = { callType: "", callId: "", role: "", actions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Grant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Grant): Grant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string call_type */ 1:
                    message.callType = reader.string();
                    break;
                case /* string call_id */ 2:
                    message.callId = reader.string();
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* repeated stream.video.Action actions */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.actions.push(reader.int32());
                    else
                        message.actions.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Grant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string call_type = 1; */
        if (message.callType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.callType);
        /* string call_id = 2; */
        if (message.callId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.callId);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* repeated stream.video.Action actions = 5; */
        if (message.actions.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.actions.length; i++)
                writer.int32(message.actions[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Grant
 */
export const Grant = new Grant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Features$Type extends MessageType<Features> {
    constructor() {
        super("stream.video.Features", [
            { no: 1, name: "recording", kind: "enum", T: () => ["stream.video.FeatureToggle", FeatureToggle, "FEATURE_TOGGLE_"] },
            { no: 3, name: "hls_broadcast", kind: "enum", T: () => ["stream.video.FeatureToggle", FeatureToggle, "FEATURE_TOGGLE_"] },
            { no: 4, name: "transcribe", kind: "enum", T: () => ["stream.video.FeatureToggle", FeatureToggle, "FEATURE_TOGGLE_"] },
            { no: 5, name: "transcribe_options", kind: "message", T: () => TranscribeOptions }
        ]);
    }
    create(value?: PartialMessage<Features>): Features {
        const message = { recording: 0, hlsBroadcast: 0, transcribe: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Features>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Features): Features {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.video.FeatureToggle recording */ 1:
                    message.recording = reader.int32();
                    break;
                case /* stream.video.FeatureToggle hls_broadcast */ 3:
                    message.hlsBroadcast = reader.int32();
                    break;
                case /* stream.video.FeatureToggle transcribe */ 4:
                    message.transcribe = reader.int32();
                    break;
                case /* stream.video.TranscribeOptions transcribe_options */ 5:
                    message.transcribeOptions = TranscribeOptions.internalBinaryRead(reader, reader.uint32(), options, message.transcribeOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Features, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.video.FeatureToggle recording = 1; */
        if (message.recording !== 0)
            writer.tag(1, WireType.Varint).int32(message.recording);
        /* stream.video.FeatureToggle hls_broadcast = 3; */
        if (message.hlsBroadcast !== 0)
            writer.tag(3, WireType.Varint).int32(message.hlsBroadcast);
        /* stream.video.FeatureToggle transcribe = 4; */
        if (message.transcribe !== 0)
            writer.tag(4, WireType.Varint).int32(message.transcribe);
        /* stream.video.TranscribeOptions transcribe_options = 5; */
        if (message.transcribeOptions)
            TranscribeOptions.internalBinaryWrite(message.transcribeOptions, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Features
 */
export const Features = new Features$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CallType$Type extends MessageType<CallType> {
    constructor() {
        super("stream.video.CallType", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "permissions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Permissions } },
            { no: 3, name: "features", kind: "message", T: () => Features },
            { no: 4, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CallType>): CallType {
        const message = { name: "", permissions: {}, createdAt: "", updatedAt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CallType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CallType): CallType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, stream.video.Permissions> permissions */ 2:
                    this.binaryReadMap2(message.permissions, reader, options);
                    break;
                case /* stream.video.Features features */ 3:
                    message.features = Features.internalBinaryRead(reader, reader.uint32(), options, message.features);
                    break;
                case /* string created_at */ 4:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 5:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: CallType["permissions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CallType["permissions"] | undefined, val: CallType["permissions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Permissions.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field stream.video.CallType.permissions");
            }
        }
        map[key ?? ""] = val ?? Permissions.create();
    }
    internalBinaryWrite(message: CallType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, stream.video.Permissions> permissions = 2; */
        for (let k of Object.keys(message.permissions)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Permissions.internalBinaryWrite(message.permissions[k], writer, options);
            writer.join().join();
        }
        /* stream.video.Features features = 3; */
        if (message.features)
            Features.internalBinaryWrite(message.features, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string created_at = 4; */
        if (message.createdAt !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 5; */
        if (message.updatedAt !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.CallType
 */
export const CallType = new CallType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Participant$Type extends MessageType<Participant> {
    constructor() {
        super("stream.video.Participant", [
            { no: 1, name: "user", kind: "message", T: () => User },
            { no: 2, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "online", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "custom", kind: "message", T: () => Struct },
            { no: 5, name: "video", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "audio", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 8, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<Participant>): Participant {
        const message = { role: "", online: false, video: false, audio: false, createdAt: "", updatedAt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Participant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Participant): Participant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.video.User user */ 1:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* string role */ 2:
                    message.role = reader.string();
                    break;
                case /* bool online */ 3:
                    message.online = reader.bool();
                    break;
                case /* google.protobuf.Struct custom */ 4:
                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);
                    break;
                case /* bool video */ 5:
                    message.video = reader.bool();
                    break;
                case /* bool audio */ 6:
                    message.audio = reader.bool();
                    break;
                case /* string created_at */ 7:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 8:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Participant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.video.User user = 1; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string role = 2; */
        if (message.role !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.role);
        /* bool online = 3; */
        if (message.online !== false)
            writer.tag(3, WireType.Varint).bool(message.online);
        /* google.protobuf.Struct custom = 4; */
        if (message.custom)
            Struct.internalBinaryWrite(message.custom, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool video = 5; */
        if (message.video !== false)
            writer.tag(5, WireType.Varint).bool(message.video);
        /* bool audio = 6; */
        if (message.audio !== false)
            writer.tag(6, WireType.Varint).bool(message.audio);
        /* string created_at = 7; */
        if (message.createdAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 8; */
        if (message.updatedAt !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Participant
 */
export const Participant = new Participant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParticipantRequest$Type extends MessageType<ParticipantRequest> {
    constructor() {
        super("stream.video.ParticipantRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "custom", kind: "message", T: () => Struct },
            { no: 4, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 5, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<ParticipantRequest>): ParticipantRequest {
        const message = { userId: "", role: "", createdAt: "", updatedAt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParticipantRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParticipantRequest): ParticipantRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string role */ 2:
                    message.role = reader.string();
                    break;
                case /* google.protobuf.Struct custom */ 3:
                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);
                    break;
                case /* string created_at */ 4:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 5:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParticipantRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string role = 2; */
        if (message.role !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.role);
        /* google.protobuf.Struct custom = 3; */
        if (message.custom)
            Struct.internalBinaryWrite(message.custom, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string created_at = 4; */
        if (message.createdAt !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 5; */
        if (message.updatedAt !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.ParticipantRequest
 */
export const ParticipantRequest = new ParticipantRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CallState$Type extends MessageType<CallState> {
    constructor() {
        super("stream.video.CallState", [
            { no: 1, name: "participants", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Participant }
        ]);
    }
    create(value?: PartialMessage<CallState>): CallState {
        const message = { participants: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CallState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CallState): CallState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated stream.video.Participant participants */ 1:
                    message.participants.push(Participant.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CallState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated stream.video.Participant participants = 1; */
        for (let i = 0; i < message.participants.length; i++)
            Participant.internalBinaryWrite(message.participants[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.CallState
 */
export const CallState = new CallState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Call$Type extends MessageType<Call> {
    constructor() {
        super("stream.video.Call", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "created_by_user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 4, name: "host_user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "custom", kind: "message", T: () => Struct },
            { no: 6, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 7, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 8, name: "recording", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "broadcast", kind: "message", T: () => Broadcast },
            { no: 10, name: "transcribe", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "transcribe_options", kind: "message", T: () => TranscribeOptions }
        ]);
    }
    create(value?: PartialMessage<Call>): Call {
        const message = { type: "", id: "", createdByUserId: "", hostUserId: "", createdAt: "", updatedAt: "", recording: false, transcribe: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Call>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Call): Call {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* string created_by_user_id */ 3:
                    message.createdByUserId = reader.string();
                    break;
                case /* string host_user_id */ 4:
                    message.hostUserId = reader.string();
                    break;
                case /* google.protobuf.Struct custom */ 5:
                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);
                    break;
                case /* string created_at */ 6:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 7:
                    message.updatedAt = reader.string();
                    break;
                case /* bool recording */ 8:
                    message.recording = reader.bool();
                    break;
                case /* stream.video.Broadcast broadcast */ 9:
                    message.broadcast = Broadcast.internalBinaryRead(reader, reader.uint32(), options, message.broadcast);
                    break;
                case /* bool transcribe */ 10:
                    message.transcribe = reader.bool();
                    break;
                case /* stream.video.TranscribeOptions transcribe_options */ 11:
                    message.transcribeOptions = TranscribeOptions.internalBinaryRead(reader, reader.uint32(), options, message.transcribeOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Call, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* string created_by_user_id = 3; */
        if (message.createdByUserId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.createdByUserId);
        /* string host_user_id = 4; */
        if (message.hostUserId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hostUserId);
        /* google.protobuf.Struct custom = 5; */
        if (message.custom)
            Struct.internalBinaryWrite(message.custom, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string created_at = 6; */
        if (message.createdAt !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 7; */
        if (message.updatedAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.updatedAt);
        /* bool recording = 8; */
        if (message.recording !== false)
            writer.tag(8, WireType.Varint).bool(message.recording);
        /* stream.video.Broadcast broadcast = 9; */
        if (message.broadcast)
            Broadcast.internalBinaryWrite(message.broadcast, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* bool transcribe = 10; */
        if (message.transcribe !== false)
            writer.tag(10, WireType.Varint).bool(message.transcribe);
        /* stream.video.TranscribeOptions transcribe_options = 11; */
        if (message.transcribeOptions)
            TranscribeOptions.internalBinaryWrite(message.transcribeOptions, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Call
 */
export const Call = new Call$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApnSettings$Type extends MessageType<ApnSettings> {
    constructor() {
        super("stream.video.ApnSettings", [
            { no: 1, name: "auth_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "apn_topic", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "team_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "development", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ApnSettings>): ApnSettings {
        const message = { authKey: "", keyId: "", apnTopic: "", teamId: "", development: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ApnSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApnSettings): ApnSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string auth_key */ 1:
                    message.authKey = reader.string();
                    break;
                case /* string key_id */ 2:
                    message.keyId = reader.string();
                    break;
                case /* string apn_topic */ 3:
                    message.apnTopic = reader.string();
                    break;
                case /* string team_id */ 4:
                    message.teamId = reader.string();
                    break;
                case /* bool development */ 5:
                    message.development = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApnSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string auth_key = 1; */
        if (message.authKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authKey);
        /* string key_id = 2; */
        if (message.keyId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyId);
        /* string apn_topic = 3; */
        if (message.apnTopic !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.apnTopic);
        /* string team_id = 4; */
        if (message.teamId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.teamId);
        /* bool development = 5; */
        if (message.development !== false)
            writer.tag(5, WireType.Varint).bool(message.development);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.ApnSettings
 */
export const ApnSettings = new ApnSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirebaseSettings$Type extends MessageType<FirebaseSettings> {
    constructor() {
        super("stream.video.FirebaseSettings", [
            { no: 1, name: "server_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "credentials_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FirebaseSettings>): FirebaseSettings {
        const message = { serverKey: "", credentialsJson: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FirebaseSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FirebaseSettings): FirebaseSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string server_key */ 1:
                    message.serverKey = reader.string();
                    break;
                case /* string credentials_json */ 2:
                    message.credentialsJson = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FirebaseSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string server_key = 1; */
        if (message.serverKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serverKey);
        /* string credentials_json = 2; */
        if (message.credentialsJson !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.credentialsJson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.FirebaseSettings
 */
export const FirebaseSettings = new FirebaseSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HuaweiSettings$Type extends MessageType<HuaweiSettings> {
    constructor() {
        super("stream.video.HuaweiSettings", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HuaweiSettings>): HuaweiSettings {
        const message = { id: "", secret: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HuaweiSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HuaweiSettings): HuaweiSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string secret */ 2:
                    message.secret = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HuaweiSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string secret = 2; */
        if (message.secret !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.secret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.HuaweiSettings
 */
export const HuaweiSettings = new HuaweiSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class XiaomiSettings$Type extends MessageType<XiaomiSettings> {
    constructor() {
        super("stream.video.XiaomiSettings", [
            { no: 1, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<XiaomiSettings>): XiaomiSettings {
        const message = { packageName: "", secret: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<XiaomiSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: XiaomiSettings): XiaomiSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string package_name */ 1:
                    message.packageName = reader.string();
                    break;
                case /* string secret */ 2:
                    message.secret = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: XiaomiSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string package_name = 1; */
        if (message.packageName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.packageName);
        /* string secret = 2; */
        if (message.secret !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.secret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.XiaomiSettings
 */
export const XiaomiSettings = new XiaomiSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SqsSettings$Type extends MessageType<SqsSettings> {
    constructor() {
        super("stream.video.SqsSettings", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SqsSettings>): SqsSettings {
        const message = { url: "", key: "", secret: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SqsSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqsSettings): SqsSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string key */ 2:
                    message.key = reader.string();
                    break;
                case /* string secret */ 3:
                    message.secret = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SqsSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string key = 2; */
        if (message.key !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.key);
        /* string secret = 3; */
        if (message.secret !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.secret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.SqsSettings
 */
export const SqsSettings = new SqsSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PushProvider$Type extends MessageType<PushProvider> {
    constructor() {
        super("stream.video.PushProvider", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "apn_settings", kind: "message", oneof: "settings", T: () => ApnSettings },
            { no: 3, name: "firebase_settings", kind: "message", oneof: "settings", T: () => FirebaseSettings },
            { no: 4, name: "huawei_settings", kind: "message", oneof: "settings", T: () => HuaweiSettings },
            { no: 5, name: "xiaomi_settings", kind: "message", oneof: "settings", T: () => XiaomiSettings },
            { no: 6, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PushProvider>): PushProvider {
        const message = { name: "", settings: { oneofKind: undefined }, disabled: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PushProvider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PushProvider): PushProvider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* stream.video.ApnSettings apn_settings */ 2:
                    message.settings = {
                        oneofKind: "apnSettings",
                        apnSettings: ApnSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).apnSettings)
                    };
                    break;
                case /* stream.video.FirebaseSettings firebase_settings */ 3:
                    message.settings = {
                        oneofKind: "firebaseSettings",
                        firebaseSettings: FirebaseSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).firebaseSettings)
                    };
                    break;
                case /* stream.video.HuaweiSettings huawei_settings */ 4:
                    message.settings = {
                        oneofKind: "huaweiSettings",
                        huaweiSettings: HuaweiSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).huaweiSettings)
                    };
                    break;
                case /* stream.video.XiaomiSettings xiaomi_settings */ 5:
                    message.settings = {
                        oneofKind: "xiaomiSettings",
                        xiaomiSettings: XiaomiSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).xiaomiSettings)
                    };
                    break;
                case /* bool disabled */ 6:
                    message.disabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PushProvider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* stream.video.ApnSettings apn_settings = 2; */
        if (message.settings.oneofKind === "apnSettings")
            ApnSettings.internalBinaryWrite(message.settings.apnSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* stream.video.FirebaseSettings firebase_settings = 3; */
        if (message.settings.oneofKind === "firebaseSettings")
            FirebaseSettings.internalBinaryWrite(message.settings.firebaseSettings, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* stream.video.HuaweiSettings huawei_settings = 4; */
        if (message.settings.oneofKind === "huaweiSettings")
            HuaweiSettings.internalBinaryWrite(message.settings.huaweiSettings, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* stream.video.XiaomiSettings xiaomi_settings = 5; */
        if (message.settings.oneofKind === "xiaomiSettings")
            XiaomiSettings.internalBinaryWrite(message.settings.xiaomiSettings, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool disabled = 6; */
        if (message.disabled !== false)
            writer.tag(6, WireType.Varint).bool(message.disabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.PushProvider
 */
export const PushProvider = new PushProvider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplicationSettings$Type extends MessageType<ApplicationSettings> {
    constructor() {
        super("stream.video.ApplicationSettings", [
            { no: 1, name: "webhook_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "push_providers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PushProvider },
            { no: 3, name: "sqs_settings", kind: "message", T: () => SqsSettings }
        ]);
    }
    create(value?: PartialMessage<ApplicationSettings>): ApplicationSettings {
        const message = { webhookUrl: "", pushProviders: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ApplicationSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplicationSettings): ApplicationSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string webhook_url */ 1:
                    message.webhookUrl = reader.string();
                    break;
                case /* repeated stream.video.PushProvider push_providers */ 2:
                    message.pushProviders.push(PushProvider.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* stream.video.SqsSettings sqs_settings */ 3:
                    message.sqsSettings = SqsSettings.internalBinaryRead(reader, reader.uint32(), options, message.sqsSettings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplicationSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string webhook_url = 1; */
        if (message.webhookUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.webhookUrl);
        /* repeated stream.video.PushProvider push_providers = 2; */
        for (let i = 0; i < message.pushProviders.length; i++)
            PushProvider.internalBinaryWrite(message.pushProviders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* stream.video.SqsSettings sqs_settings = 3; */
        if (message.sqsSettings)
            SqsSettings.internalBinaryWrite(message.sqsSettings, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.ApplicationSettings
 */
export const ApplicationSettings = new ApplicationSettings$Type();
