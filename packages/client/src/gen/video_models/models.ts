// @generated by protobuf-ts 2.7.0 with parameter long_type_string,generate_dependencies,client_generic,server_none
// @generated from protobuf file "video_models/models.proto" (package "stream.video", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Struct } from "../google/protobuf/struct";
/**
 * Edges are where we deploy video servers
 *
 * @generated from protobuf message stream.video.Edge
 */
export interface Edge {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string latency_url = 2;
     */
    latencyUrl: string;
}
// TODO: to discuss. do we keep a log per call of
// - people joining
// - reactions
// - etc?
// - maybe it only makes sense when you transcribe the call

/**
 * Edges are where we deploy video servers
 *
 * @generated from protobuf message stream.video.EdgeServer
 */
export interface EdgeServer {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
}
/**
 * @generated from protobuf message stream.video.Latency
 */
export interface Latency {
    /**
     * @generated from protobuf field: repeated float measurements_seconds = 1;
     */
    measurementsSeconds: number[];
}
/**
 * 3 different type of broadcast
 *
 * @generated from protobuf message stream.video.Broadcast
 */
export interface Broadcast {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf oneof: Details
     */
    details: {
        oneofKind: "rtmp";
        /**
         * @generated from protobuf field: stream.video.RTMPBroadcast rtmp = 2;
         */
        rtmp: RTMPBroadcast;
    } | {
        oneofKind: "hls";
        /**
         * @generated from protobuf field: stream.video.HLSBroadcast hls = 3;
         */
        hls: HLSBroadcast;
    } | {
        oneofKind: "record";
        /**
         * @generated from protobuf field: stream.video.RecordBroadcast record = 4;
         */
        record: RecordBroadcast;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message stream.video.RTMPBroadcast
 */
export interface RTMPBroadcast {
    /**
     * @generated from protobuf field: string call_id = 1;
     */
    callId: string;
    /**
     * @generated from protobuf field: repeated string rtmpurls = 2;
     */
    rtmpurls: string[];
    /**
     * @generated from protobuf field: int32 width = 3;
     */
    width: number;
    /**
     * @generated from protobuf field: int32 height = 4;
     */
    height: number;
}
/**
 * @generated from protobuf message stream.video.HLSBroadcast
 */
export interface HLSBroadcast {
}
/**
 * @generated from protobuf message stream.video.File
 */
export interface File {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: bool composite = 2;
     */
    composite: boolean;
    /**
     * @generated from protobuf field: string user_id = 3;
     */
    userId: string;
    /**
     * @generated from protobuf field: string url = 4;
     */
    url: string;
}
/**
 * @generated from protobuf message stream.video.RecordBroadcast
 */
export interface RecordBroadcast {
    /**
     * @generated from protobuf field: bool composite = 1;
     */
    composite: boolean; // if true merge all audio and video, if false split them
    /**
     * @generated from protobuf field: repeated stream.video.File files = 2;
     */
    files: File[];
}
/**
 * @generated from protobuf message stream.video.User
 */
export interface User {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: repeated string teams = 2;
     */
    teams: string[];
    /**
     * @generated from protobuf field: string role = 3;
     */
    role: string;
    /**
     * @generated from protobuf field: google.protobuf.Struct custom = 4;
     */
    custom?: Struct;
    /**
     * @generated from protobuf field: string name = 5;
     */
    name: string;
    /**
     * @generated from protobuf field: string profile_image_url = 6;
     */
    profileImageUrl: string;
    /**
     * user creation date as RFC3339 string
     *
     * @generated from protobuf field: string created_at = 7;
     */
    createdAt: string;
    /**
     * user last update date as RFC3339 string
     *
     * @generated from protobuf field: string updated_at = 8;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message stream.video.UserRequest
 */
export interface UserRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: repeated string teams = 2;
     */
    teams: string[];
    /**
     * @generated from protobuf field: string role = 3;
     */
    role: string;
    /**
     * @generated from protobuf field: google.protobuf.Struct custom = 4;
     */
    custom?: Struct;
    /**
     * @generated from protobuf field: string name = 5;
     */
    name: string;
    /**
     * @generated from protobuf field: string profile_image_url = 6;
     */
    profileImageUrl: string;
}
/**
 * @generated from protobuf message stream.video.Device
 */
export interface Device {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: bool disabled = 3;
     */
    disabled: boolean;
    /**
     * @generated from protobuf field: string disabled_reason = 4;
     */
    disabledReason: string;
    /**
     * @generated from protobuf field: string push_provider_name = 5;
     */
    pushProviderName: string;
    /**
     * @generated from protobuf field: string created_at = 6;
     */
    createdAt: string;
    /**
     * @generated from protobuf field: string updated_at = 7;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message stream.video.DeviceRequest
 */
export interface DeviceRequest {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: bool disabled = 3;
     */
    disabled: boolean;
    /**
     * @generated from protobuf field: string disabled_reason = 4;
     */
    disabledReason: string;
    /**
     * @generated from protobuf field: string push_provider_name = 5;
     */
    pushProviderName: string;
}
/**
 * @generated from protobuf message stream.video.RecordingStorageOptions
 */
export interface RecordingStorageOptions {
    /**
     * @generated from protobuf field: stream.video.RecordingStorage storage = 2;
     */
    storage: RecordingStorage;
    /**
     * @generated from protobuf field: string access_key = 3;
     */
    accessKey: string;
    /**
     * @generated from protobuf field: string secret_key = 4;
     */
    secretKey: string;
    /**
     * @generated from protobuf field: string bucket_name = 5;
     */
    bucketName: string;
    /**
     * @generated from protobuf field: string region = 6;
     */
    region: string;
    /**
     * @generated from protobuf field: string path = 7;
     */
    path: string;
}
/**
 * @generated from protobuf message stream.video.BroadcastOptions
 */
export interface BroadcastOptions {
    /**
     * @generated from protobuf field: string rtmp_url = 1;
     */
    rtmpUrl: string;
    /**
     * @generated from protobuf field: string hls_url = 2;
     */
    hlsUrl: string;
}
/**
 * @generated from protobuf message stream.video.TranscribeOptions
 */
export interface TranscribeOptions {
}
/**
 * @generated from protobuf message stream.video.CallType
 */
export interface CallType {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: stream.video.Security security = 2;
     */
    security?: Security;
    /**
     * enable broadcasting by default when creating a call of this type
     *
     * @generated from protobuf field: bool broadcast = 3;
     */
    broadcast: boolean;
    /**
     * @generated from protobuf field: repeated stream.video.BroadcastOptions broadcast_options = 4;
     */
    broadcastOptions: BroadcastOptions[];
    /**
     * enable transcription by default
     *
     * @generated from protobuf field: bool transcribe = 5;
     */
    transcribe: boolean;
    /**
     * @generated from protobuf field: stream.video.TranscribeOptions transcribe_options = 6;
     */
    transcribeOptions?: TranscribeOptions;
    /**
     * @generated from protobuf field: string created_at = 7;
     */
    createdAt: string;
    /**
     * @generated from protobuf field: string updated_at = 8;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message stream.video.Security
 */
export interface Security {
    /**
     * @generated from protobuf field: bool hide_profile_pictures = 1;
     */
    hideProfilePictures: boolean;
    /**
     * @generated from protobuf field: stream.video.Security.IsAllowed share_screen = 2;
     */
    shareScreen: Security_IsAllowed;
    /**
     * @generated from protobuf field: bool rename_user = 3;
     */
    renameUser: boolean;
    /**
     * @generated from protobuf field: stream.video.Security.IsAllowed unmute = 4;
     */
    unmute: Security_IsAllowed;
    /**
     * @generated from protobuf field: stream.video.Security.IsAllowed start_video = 5;
     */
    startVideo: Security_IsAllowed;
    /**
     * @generated from protobuf field: stream.video.Security.IsAllowed screen_share = 6;
     */
    screenShare: Security_IsAllowed;
    /**
     * @generated from protobuf field: stream.video.Security.IsAllowed record = 7;
     */
    record: Security_IsAllowed;
    /**
     * @generated from protobuf field: stream.video.Security.IsAllowed broadcast = 8;
     */
    broadcast: Security_IsAllowed;
}
/**
 * TODO this is actually one of the most complex UI things in zoom :)
 * controls if regular users are allowed to do the following
 * yes/no/request
 *
 * @generated from protobuf enum stream.video.Security.IsAllowed
 */
export enum Security_IsAllowed {
    /**
     * @generated from protobuf enum value: IS_ALLOWED_YES_UNSPECIFIED = 0;
     */
    YES_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: IS_ALLOWED_NO = 1;
     */
    NO = 1,
    /**
     * @generated from protobuf enum value: IS_ALLOWED_REQUEST = 2;
     */
    REQUEST = 2
}
/**
 * those who are online in the call
 *
 * @generated from protobuf message stream.video.Participant
 */
export interface Participant {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string role = 2;
     */
    role: string;
    /**
     * @generated from protobuf field: bool online = 3;
     */
    online: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Struct custom = 4;
     */
    custom?: Struct;
    /**
     * call creation date as RFC3339 string
     *
     * @generated from protobuf field: string created_at = 5;
     */
    createdAt: string;
    /**
     * call last update date as RFC3339 string
     *
     * @generated from protobuf field: string updated_at = 6;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message stream.video.ParticipantRequest
 */
export interface ParticipantRequest {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string role = 2;
     */
    role: string;
    /**
     * call custom data
     *
     * @generated from protobuf field: google.protobuf.Struct custom = 3;
     */
    custom?: Struct;
    /**
     * call creation date as RFC3339 string
     *
     * @generated from protobuf field: string created_at = 4;
     */
    createdAt: string;
    /**
     * call last update date as RFC3339 string
     *
     * @generated from protobuf field: string updated_at = 5;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message stream.video.CallState
 */
export interface CallState {
    /**
     * @generated from protobuf field: repeated stream.video.Participant participants = 1;
     */
    participants: Participant[];
}
/**
 * @generated from protobuf message stream.video.Call
 */
export interface Call {
    /**
     * the call type
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * the call id
     *
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * the id of the user that created this call
     *
     * @generated from protobuf field: string created_by_user_id = 3;
     */
    createdByUserId: string;
    /**
     * call custom data
     *
     * @generated from protobuf field: google.protobuf.Struct custom = 4;
     */
    custom?: Struct;
    /**
     * call creation date as RFC3339 string
     *
     * @generated from protobuf field: string created_at = 5;
     */
    createdAt: string;
    /**
     * call last update date as RFC3339 string
     *
     * @generated from protobuf field: string updated_at = 6;
     */
    updatedAt: string;
    /**
     * enable broadcasting by default when creating a call of this type
     *
     * @generated from protobuf field: bool broadcast = 7;
     */
    broadcast: boolean;
    /**
     * @generated from protobuf field: repeated stream.video.BroadcastOptions broadcast_options = 8;
     */
    broadcastOptions: BroadcastOptions[];
    /**
     * enable transcription by default
     *
     * @generated from protobuf field: bool transcribe = 9;
     */
    transcribe: boolean;
    /**
     * @generated from protobuf field: stream.video.TranscribeOptions transcribe_options = 10;
     */
    transcribeOptions?: TranscribeOptions;
}
/**
 * @generated from protobuf enum stream.video.Codec
 */
export enum Codec {
    /**
     * @generated from protobuf enum value: CODEC_H264_UNSPECIFIED = 0;
     */
    H264_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: CODEC_VP8 = 1;
     */
    VP8 = 1,
    /**
     * @generated from protobuf enum value: CODEC_VP9 = 2;
     */
    VP9 = 2
}
/**
 * @generated from protobuf enum stream.video.RecordingStorage
 */
export enum RecordingStorage {
    /**
     * @generated from protobuf enum value: RECORDING_STORAGE_S3_UNSPECIFIED = 0;
     */
    S3_UNSPECIFIED = 0
}
// @generated message type with reflection information, may provide speed optimized methods
class Edge$Type extends MessageType<Edge> {
    constructor() {
        super("stream.video.Edge", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "latency_url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<Edge>): Edge {
        const message = { name: "", latencyUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Edge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Edge): Edge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string latency_url */ 2:
                    message.latencyUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Edge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string latency_url = 2; */
        if (message.latencyUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.latencyUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Edge
 */
export const Edge = new Edge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EdgeServer$Type extends MessageType<EdgeServer> {
    constructor() {
        super("stream.video.EdgeServer", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EdgeServer>): EdgeServer {
        const message = { url: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EdgeServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EdgeServer): EdgeServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EdgeServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.EdgeServer
 */
export const EdgeServer = new EdgeServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Latency$Type extends MessageType<Latency> {
    constructor() {
        super("stream.video.Latency", [
            { no: 1, name: "measurements_seconds", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Latency>): Latency {
        const message = { measurementsSeconds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Latency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Latency): Latency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float measurements_seconds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.measurementsSeconds.push(reader.float());
                    else
                        message.measurementsSeconds.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Latency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated float measurements_seconds = 1; */
        if (message.measurementsSeconds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.measurementsSeconds.length; i++)
                writer.float(message.measurementsSeconds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Latency
 */
export const Latency = new Latency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Broadcast$Type extends MessageType<Broadcast> {
    constructor() {
        super("stream.video.Broadcast", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rtmp", kind: "message", oneof: "details", T: () => RTMPBroadcast },
            { no: 3, name: "hls", kind: "message", oneof: "details", T: () => HLSBroadcast },
            { no: 4, name: "record", kind: "message", oneof: "details", T: () => RecordBroadcast }
        ]);
    }
    create(value?: PartialMessage<Broadcast>): Broadcast {
        const message = { id: "", details: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Broadcast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Broadcast): Broadcast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* stream.video.RTMPBroadcast rtmp */ 2:
                    message.details = {
                        oneofKind: "rtmp",
                        rtmp: RTMPBroadcast.internalBinaryRead(reader, reader.uint32(), options, (message.details as any).rtmp)
                    };
                    break;
                case /* stream.video.HLSBroadcast hls */ 3:
                    message.details = {
                        oneofKind: "hls",
                        hls: HLSBroadcast.internalBinaryRead(reader, reader.uint32(), options, (message.details as any).hls)
                    };
                    break;
                case /* stream.video.RecordBroadcast record */ 4:
                    message.details = {
                        oneofKind: "record",
                        record: RecordBroadcast.internalBinaryRead(reader, reader.uint32(), options, (message.details as any).record)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Broadcast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* stream.video.RTMPBroadcast rtmp = 2; */
        if (message.details.oneofKind === "rtmp")
            RTMPBroadcast.internalBinaryWrite(message.details.rtmp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* stream.video.HLSBroadcast hls = 3; */
        if (message.details.oneofKind === "hls")
            HLSBroadcast.internalBinaryWrite(message.details.hls, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* stream.video.RecordBroadcast record = 4; */
        if (message.details.oneofKind === "record")
            RecordBroadcast.internalBinaryWrite(message.details.record, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Broadcast
 */
export const Broadcast = new Broadcast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RTMPBroadcast$Type extends MessageType<RTMPBroadcast> {
    constructor() {
        super("stream.video.RTMPBroadcast", [
            { no: 1, name: "call_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rtmpurls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "height", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RTMPBroadcast>): RTMPBroadcast {
        const message = { callId: "", rtmpurls: [], width: 0, height: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RTMPBroadcast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RTMPBroadcast): RTMPBroadcast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string call_id */ 1:
                    message.callId = reader.string();
                    break;
                case /* repeated string rtmpurls */ 2:
                    message.rtmpurls.push(reader.string());
                    break;
                case /* int32 width */ 3:
                    message.width = reader.int32();
                    break;
                case /* int32 height */ 4:
                    message.height = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RTMPBroadcast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string call_id = 1; */
        if (message.callId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.callId);
        /* repeated string rtmpurls = 2; */
        for (let i = 0; i < message.rtmpurls.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.rtmpurls[i]);
        /* int32 width = 3; */
        if (message.width !== 0)
            writer.tag(3, WireType.Varint).int32(message.width);
        /* int32 height = 4; */
        if (message.height !== 0)
            writer.tag(4, WireType.Varint).int32(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.RTMPBroadcast
 */
export const RTMPBroadcast = new RTMPBroadcast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HLSBroadcast$Type extends MessageType<HLSBroadcast> {
    constructor() {
        super("stream.video.HLSBroadcast", []);
    }
    create(value?: PartialMessage<HLSBroadcast>): HLSBroadcast {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HLSBroadcast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HLSBroadcast): HLSBroadcast {
        return target ?? this.create();
    }
    internalBinaryWrite(message: HLSBroadcast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.HLSBroadcast
 */
export const HLSBroadcast = new HLSBroadcast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class File$Type extends MessageType<File> {
    constructor() {
        super("stream.video.File", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "composite", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<File>): File {
        const message = { type: "", composite: false, userId: "", url: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<File>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: File): File {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bool composite */ 2:
                    message.composite = reader.bool();
                    break;
                case /* string user_id */ 3:
                    message.userId = reader.string();
                    break;
                case /* string url */ 4:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: File, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* bool composite = 2; */
        if (message.composite !== false)
            writer.tag(2, WireType.Varint).bool(message.composite);
        /* string user_id = 3; */
        if (message.userId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        /* string url = 4; */
        if (message.url !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.File
 */
export const File = new File$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordBroadcast$Type extends MessageType<RecordBroadcast> {
    constructor() {
        super("stream.video.RecordBroadcast", [
            { no: 1, name: "composite", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "files", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => File }
        ]);
    }
    create(value?: PartialMessage<RecordBroadcast>): RecordBroadcast {
        const message = { composite: false, files: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RecordBroadcast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordBroadcast): RecordBroadcast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool composite */ 1:
                    message.composite = reader.bool();
                    break;
                case /* repeated stream.video.File files */ 2:
                    message.files.push(File.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordBroadcast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool composite = 1; */
        if (message.composite !== false)
            writer.tag(1, WireType.Varint).bool(message.composite);
        /* repeated stream.video.File files = 2; */
        for (let i = 0; i < message.files.length; i++)
            File.internalBinaryWrite(message.files[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.RecordBroadcast
 */
export const RecordBroadcast = new RecordBroadcast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("stream.video.User", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "teams", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "custom", kind: "message", T: () => Struct },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "profile_image_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = { id: "", teams: [], role: "", name: "", profileImageUrl: "", createdAt: "", updatedAt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated string teams */ 2:
                    message.teams.push(reader.string());
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* google.protobuf.Struct custom */ 4:
                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* string profile_image_url */ 6:
                    message.profileImageUrl = reader.string();
                    break;
                case /* string created_at */ 7:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 8:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated string teams = 2; */
        for (let i = 0; i < message.teams.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.teams[i]);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* google.protobuf.Struct custom = 4; */
        if (message.custom)
            Struct.internalBinaryWrite(message.custom, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* string profile_image_url = 6; */
        if (message.profileImageUrl !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.profileImageUrl);
        /* string created_at = 7; */
        if (message.createdAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 8; */
        if (message.updatedAt !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserRequest$Type extends MessageType<UserRequest> {
    constructor() {
        super("stream.video.UserRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "teams", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "custom", kind: "message", T: () => Struct },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "profile_image_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserRequest>): UserRequest {
        const message = { id: "", teams: [], role: "", name: "", profileImageUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserRequest): UserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated string teams */ 2:
                    message.teams.push(reader.string());
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* google.protobuf.Struct custom */ 4:
                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* string profile_image_url */ 6:
                    message.profileImageUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated string teams = 2; */
        for (let i = 0; i < message.teams.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.teams[i]);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* google.protobuf.Struct custom = 4; */
        if (message.custom)
            Struct.internalBinaryWrite(message.custom, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* string profile_image_url = 6; */
        if (message.profileImageUrl !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.profileImageUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.UserRequest
 */
export const UserRequest = new UserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Device$Type extends MessageType<Device> {
    constructor() {
        super("stream.video.Device", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "disabled_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "push_provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Device>): Device {
        const message = { userId: "", id: "", disabled: false, disabledReason: "", pushProviderName: "", createdAt: "", updatedAt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Device>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Device): Device {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* bool disabled */ 3:
                    message.disabled = reader.bool();
                    break;
                case /* string disabled_reason */ 4:
                    message.disabledReason = reader.string();
                    break;
                case /* string push_provider_name */ 5:
                    message.pushProviderName = reader.string();
                    break;
                case /* string created_at */ 6:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 7:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Device, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* bool disabled = 3; */
        if (message.disabled !== false)
            writer.tag(3, WireType.Varint).bool(message.disabled);
        /* string disabled_reason = 4; */
        if (message.disabledReason !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.disabledReason);
        /* string push_provider_name = 5; */
        if (message.pushProviderName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pushProviderName);
        /* string created_at = 6; */
        if (message.createdAt !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 7; */
        if (message.updatedAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Device
 */
export const Device = new Device$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceRequest$Type extends MessageType<DeviceRequest> {
    constructor() {
        super("stream.video.DeviceRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "disabled_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "push_provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeviceRequest>): DeviceRequest {
        const message = { userId: "", id: "", disabled: false, disabledReason: "", pushProviderName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceRequest): DeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* bool disabled */ 3:
                    message.disabled = reader.bool();
                    break;
                case /* string disabled_reason */ 4:
                    message.disabledReason = reader.string();
                    break;
                case /* string push_provider_name */ 5:
                    message.pushProviderName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* bool disabled = 3; */
        if (message.disabled !== false)
            writer.tag(3, WireType.Varint).bool(message.disabled);
        /* string disabled_reason = 4; */
        if (message.disabledReason !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.disabledReason);
        /* string push_provider_name = 5; */
        if (message.pushProviderName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pushProviderName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.DeviceRequest
 */
export const DeviceRequest = new DeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingStorageOptions$Type extends MessageType<RecordingStorageOptions> {
    constructor() {
        super("stream.video.RecordingStorageOptions", [
            { no: 2, name: "storage", kind: "enum", T: () => ["stream.video.RecordingStorage", RecordingStorage, "RECORDING_STORAGE_"] },
            { no: 3, name: "access_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "secret_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RecordingStorageOptions>): RecordingStorageOptions {
        const message = { storage: 0, accessKey: "", secretKey: "", bucketName: "", region: "", path: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RecordingStorageOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordingStorageOptions): RecordingStorageOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.video.RecordingStorage storage */ 2:
                    message.storage = reader.int32();
                    break;
                case /* string access_key */ 3:
                    message.accessKey = reader.string();
                    break;
                case /* string secret_key */ 4:
                    message.secretKey = reader.string();
                    break;
                case /* string bucket_name */ 5:
                    message.bucketName = reader.string();
                    break;
                case /* string region */ 6:
                    message.region = reader.string();
                    break;
                case /* string path */ 7:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordingStorageOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.video.RecordingStorage storage = 2; */
        if (message.storage !== 0)
            writer.tag(2, WireType.Varint).int32(message.storage);
        /* string access_key = 3; */
        if (message.accessKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accessKey);
        /* string secret_key = 4; */
        if (message.secretKey !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.secretKey);
        /* string bucket_name = 5; */
        if (message.bucketName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.bucketName);
        /* string region = 6; */
        if (message.region !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.region);
        /* string path = 7; */
        if (message.path !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.RecordingStorageOptions
 */
export const RecordingStorageOptions = new RecordingStorageOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BroadcastOptions$Type extends MessageType<BroadcastOptions> {
    constructor() {
        super("stream.video.BroadcastOptions", [
            { no: 1, name: "rtmp_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hls_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BroadcastOptions>): BroadcastOptions {
        const message = { rtmpUrl: "", hlsUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BroadcastOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BroadcastOptions): BroadcastOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string rtmp_url */ 1:
                    message.rtmpUrl = reader.string();
                    break;
                case /* string hls_url */ 2:
                    message.hlsUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BroadcastOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string rtmp_url = 1; */
        if (message.rtmpUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rtmpUrl);
        /* string hls_url = 2; */
        if (message.hlsUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hlsUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.BroadcastOptions
 */
export const BroadcastOptions = new BroadcastOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranscribeOptions$Type extends MessageType<TranscribeOptions> {
    constructor() {
        super("stream.video.TranscribeOptions", []);
    }
    create(value?: PartialMessage<TranscribeOptions>): TranscribeOptions {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TranscribeOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranscribeOptions): TranscribeOptions {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TranscribeOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.TranscribeOptions
 */
export const TranscribeOptions = new TranscribeOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CallType$Type extends MessageType<CallType> {
    constructor() {
        super("stream.video.CallType", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "security", kind: "message", T: () => Security },
            { no: 3, name: "broadcast", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "broadcast_options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BroadcastOptions },
            { no: 5, name: "transcribe", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "transcribe_options", kind: "message", T: () => TranscribeOptions },
            { no: 7, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CallType>): CallType {
        const message = { name: "", broadcast: false, broadcastOptions: [], transcribe: false, createdAt: "", updatedAt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CallType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CallType): CallType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* stream.video.Security security */ 2:
                    message.security = Security.internalBinaryRead(reader, reader.uint32(), options, message.security);
                    break;
                case /* bool broadcast */ 3:
                    message.broadcast = reader.bool();
                    break;
                case /* repeated stream.video.BroadcastOptions broadcast_options */ 4:
                    message.broadcastOptions.push(BroadcastOptions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool transcribe */ 5:
                    message.transcribe = reader.bool();
                    break;
                case /* stream.video.TranscribeOptions transcribe_options */ 6:
                    message.transcribeOptions = TranscribeOptions.internalBinaryRead(reader, reader.uint32(), options, message.transcribeOptions);
                    break;
                case /* string created_at */ 7:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 8:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CallType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* stream.video.Security security = 2; */
        if (message.security)
            Security.internalBinaryWrite(message.security, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool broadcast = 3; */
        if (message.broadcast !== false)
            writer.tag(3, WireType.Varint).bool(message.broadcast);
        /* repeated stream.video.BroadcastOptions broadcast_options = 4; */
        for (let i = 0; i < message.broadcastOptions.length; i++)
            BroadcastOptions.internalBinaryWrite(message.broadcastOptions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool transcribe = 5; */
        if (message.transcribe !== false)
            writer.tag(5, WireType.Varint).bool(message.transcribe);
        /* stream.video.TranscribeOptions transcribe_options = 6; */
        if (message.transcribeOptions)
            TranscribeOptions.internalBinaryWrite(message.transcribeOptions, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string created_at = 7; */
        if (message.createdAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 8; */
        if (message.updatedAt !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.CallType
 */
export const CallType = new CallType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Security$Type extends MessageType<Security> {
    constructor() {
        super("stream.video.Security", [
            { no: 1, name: "hide_profile_pictures", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "share_screen", kind: "enum", T: () => ["stream.video.Security.IsAllowed", Security_IsAllowed, "IS_ALLOWED_"] },
            { no: 3, name: "rename_user", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "unmute", kind: "enum", T: () => ["stream.video.Security.IsAllowed", Security_IsAllowed, "IS_ALLOWED_"] },
            { no: 5, name: "start_video", kind: "enum", T: () => ["stream.video.Security.IsAllowed", Security_IsAllowed, "IS_ALLOWED_"] },
            { no: 6, name: "screen_share", kind: "enum", T: () => ["stream.video.Security.IsAllowed", Security_IsAllowed, "IS_ALLOWED_"] },
            { no: 7, name: "record", kind: "enum", T: () => ["stream.video.Security.IsAllowed", Security_IsAllowed, "IS_ALLOWED_"] },
            { no: 8, name: "broadcast", kind: "enum", T: () => ["stream.video.Security.IsAllowed", Security_IsAllowed, "IS_ALLOWED_"] }
        ]);
    }
    create(value?: PartialMessage<Security>): Security {
        const message = { hideProfilePictures: false, shareScreen: 0, renameUser: false, unmute: 0, startVideo: 0, screenShare: 0, record: 0, broadcast: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Security>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Security): Security {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool hide_profile_pictures */ 1:
                    message.hideProfilePictures = reader.bool();
                    break;
                case /* stream.video.Security.IsAllowed share_screen */ 2:
                    message.shareScreen = reader.int32();
                    break;
                case /* bool rename_user */ 3:
                    message.renameUser = reader.bool();
                    break;
                case /* stream.video.Security.IsAllowed unmute */ 4:
                    message.unmute = reader.int32();
                    break;
                case /* stream.video.Security.IsAllowed start_video */ 5:
                    message.startVideo = reader.int32();
                    break;
                case /* stream.video.Security.IsAllowed screen_share */ 6:
                    message.screenShare = reader.int32();
                    break;
                case /* stream.video.Security.IsAllowed record */ 7:
                    message.record = reader.int32();
                    break;
                case /* stream.video.Security.IsAllowed broadcast */ 8:
                    message.broadcast = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Security, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool hide_profile_pictures = 1; */
        if (message.hideProfilePictures !== false)
            writer.tag(1, WireType.Varint).bool(message.hideProfilePictures);
        /* stream.video.Security.IsAllowed share_screen = 2; */
        if (message.shareScreen !== 0)
            writer.tag(2, WireType.Varint).int32(message.shareScreen);
        /* bool rename_user = 3; */
        if (message.renameUser !== false)
            writer.tag(3, WireType.Varint).bool(message.renameUser);
        /* stream.video.Security.IsAllowed unmute = 4; */
        if (message.unmute !== 0)
            writer.tag(4, WireType.Varint).int32(message.unmute);
        /* stream.video.Security.IsAllowed start_video = 5; */
        if (message.startVideo !== 0)
            writer.tag(5, WireType.Varint).int32(message.startVideo);
        /* stream.video.Security.IsAllowed screen_share = 6; */
        if (message.screenShare !== 0)
            writer.tag(6, WireType.Varint).int32(message.screenShare);
        /* stream.video.Security.IsAllowed record = 7; */
        if (message.record !== 0)
            writer.tag(7, WireType.Varint).int32(message.record);
        /* stream.video.Security.IsAllowed broadcast = 8; */
        if (message.broadcast !== 0)
            writer.tag(8, WireType.Varint).int32(message.broadcast);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Security
 */
export const Security = new Security$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Participant$Type extends MessageType<Participant> {
    constructor() {
        super("stream.video.Participant", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "online", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "custom", kind: "message", T: () => Struct },
            { no: 5, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 6, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<Participant>): Participant {
        const message = { userId: "", role: "", online: false, createdAt: "", updatedAt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Participant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Participant): Participant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string role */ 2:
                    message.role = reader.string();
                    break;
                case /* bool online */ 3:
                    message.online = reader.bool();
                    break;
                case /* google.protobuf.Struct custom */ 4:
                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);
                    break;
                case /* string created_at */ 5:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 6:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Participant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string role = 2; */
        if (message.role !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.role);
        /* bool online = 3; */
        if (message.online !== false)
            writer.tag(3, WireType.Varint).bool(message.online);
        /* google.protobuf.Struct custom = 4; */
        if (message.custom)
            Struct.internalBinaryWrite(message.custom, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string created_at = 5; */
        if (message.createdAt !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 6; */
        if (message.updatedAt !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Participant
 */
export const Participant = new Participant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParticipantRequest$Type extends MessageType<ParticipantRequest> {
    constructor() {
        super("stream.video.ParticipantRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "custom", kind: "message", T: () => Struct },
            { no: 4, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 5, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<ParticipantRequest>): ParticipantRequest {
        const message = { userId: "", role: "", createdAt: "", updatedAt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParticipantRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParticipantRequest): ParticipantRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string role */ 2:
                    message.role = reader.string();
                    break;
                case /* google.protobuf.Struct custom */ 3:
                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);
                    break;
                case /* string created_at */ 4:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 5:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParticipantRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string role = 2; */
        if (message.role !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.role);
        /* google.protobuf.Struct custom = 3; */
        if (message.custom)
            Struct.internalBinaryWrite(message.custom, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string created_at = 4; */
        if (message.createdAt !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 5; */
        if (message.updatedAt !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.ParticipantRequest
 */
export const ParticipantRequest = new ParticipantRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CallState$Type extends MessageType<CallState> {
    constructor() {
        super("stream.video.CallState", [
            { no: 1, name: "participants", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Participant }
        ]);
    }
    create(value?: PartialMessage<CallState>): CallState {
        const message = { participants: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CallState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CallState): CallState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated stream.video.Participant participants */ 1:
                    message.participants.push(Participant.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CallState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated stream.video.Participant participants = 1; */
        for (let i = 0; i < message.participants.length; i++)
            Participant.internalBinaryWrite(message.participants[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.CallState
 */
export const CallState = new CallState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Call$Type extends MessageType<Call> {
    constructor() {
        super("stream.video.Call", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "created_by_user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 4, name: "custom", kind: "message", T: () => Struct },
            { no: 5, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 6, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 7, name: "broadcast", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "broadcast_options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BroadcastOptions },
            { no: 9, name: "transcribe", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "transcribe_options", kind: "message", T: () => TranscribeOptions }
        ]);
    }
    create(value?: PartialMessage<Call>): Call {
        const message = { type: "", id: "", createdByUserId: "", createdAt: "", updatedAt: "", broadcast: false, broadcastOptions: [], transcribe: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Call>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Call): Call {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* string created_by_user_id */ 3:
                    message.createdByUserId = reader.string();
                    break;
                case /* google.protobuf.Struct custom */ 4:
                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);
                    break;
                case /* string created_at */ 5:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 6:
                    message.updatedAt = reader.string();
                    break;
                case /* bool broadcast */ 7:
                    message.broadcast = reader.bool();
                    break;
                case /* repeated stream.video.BroadcastOptions broadcast_options */ 8:
                    message.broadcastOptions.push(BroadcastOptions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool transcribe */ 9:
                    message.transcribe = reader.bool();
                    break;
                case /* stream.video.TranscribeOptions transcribe_options */ 10:
                    message.transcribeOptions = TranscribeOptions.internalBinaryRead(reader, reader.uint32(), options, message.transcribeOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Call, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* string created_by_user_id = 3; */
        if (message.createdByUserId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.createdByUserId);
        /* google.protobuf.Struct custom = 4; */
        if (message.custom)
            Struct.internalBinaryWrite(message.custom, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string created_at = 5; */
        if (message.createdAt !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 6; */
        if (message.updatedAt !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.updatedAt);
        /* bool broadcast = 7; */
        if (message.broadcast !== false)
            writer.tag(7, WireType.Varint).bool(message.broadcast);
        /* repeated stream.video.BroadcastOptions broadcast_options = 8; */
        for (let i = 0; i < message.broadcastOptions.length; i++)
            BroadcastOptions.internalBinaryWrite(message.broadcastOptions[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool transcribe = 9; */
        if (message.transcribe !== false)
            writer.tag(9, WireType.Varint).bool(message.transcribe);
        /* stream.video.TranscribeOptions transcribe_options = 10; */
        if (message.transcribeOptions)
            TranscribeOptions.internalBinaryWrite(message.transcribeOptions, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.video.Call
 */
export const Call = new Call$Type();
